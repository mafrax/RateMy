"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./app/globals.css":
/*!*************************!*\
  !*** ./app/globals.css ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"033b934db916\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9nbG9iYWxzLmNzcyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2dsb2JhbHMuY3NzP2Q1YzYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCIwMzNiOTM0ZGI5MTZcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./contexts/RatingCacheContext.tsx":
/*!*****************************************!*\
  !*** ./contexts/RatingCacheContext.tsx ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RatingCacheProvider: function() { return /* binding */ RatingCacheProvider; },\n/* harmony export */   useRatingCache: function() { return /* binding */ useRatingCache; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next-auth/react */ \"(app-pages-browser)/./node_modules/next-auth/react/index.js\");\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_auth_react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react_hot_toast__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-hot-toast */ \"(app-pages-browser)/./node_modules/react-hot-toast/dist/index.mjs\");\n/* __next_internal_client_entry_do_not_use__ RatingCacheProvider,useRatingCache auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\nconst RatingCacheContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nconst DEFAULT_DEBOUNCE_DELAY = 3000 // 3 seconds\n;\nconst MAX_CACHE_AGE = 30000 // 30 seconds max age before forced flush\n;\nconst STORAGE_KEY = \"ratemy_pending_ratings\";\nconst DEBOUNCE_DELAY_KEY = \"ratemy_debounce_delay\";\nfunction RatingCacheProvider(param) {\n    let { children } = param;\n    _s();\n    const { data: session } = (0,next_auth_react__WEBPACK_IMPORTED_MODULE_2__.useSession)();\n    const [pendingRatings, setPendingRatings] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(new Map());\n    const [debounceTimer, setDebounceTimer] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [debounceDelay, setDebounceDelayState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(DEFAULT_DEBOUNCE_DELAY);\n    const [isInitialized, setIsInitialized] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Use a ref to avoid stale closure issues with the timer\n    const flushPendingRatingsRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Generate cache key for a rating\n    const getCacheKey = (videoId, tagId)=>\"\".concat(videoId, \":\").concat(tagId);\n    // Load pending ratings from localStorage\n    const loadFromStorage = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (false) {}\n        try {\n            const stored = localStorage.getItem(STORAGE_KEY);\n            if (!stored) return new Map();\n            const parsed = JSON.parse(stored);\n            const ratingsMap = new Map(parsed);\n            // Filter out old ratings\n            const now = Date.now();\n            const filteredMap = new Map();\n            ratingsMap.forEach((rating, key)=>{\n                if (now - rating.timestamp <= MAX_CACHE_AGE) {\n                    filteredMap.set(key, rating);\n                }\n            });\n            return filteredMap;\n        } catch (error) {\n            console.warn(\"Failed to load pending ratings from storage:\", error);\n            return new Map();\n        }\n    }, []);\n    // Save pending ratings to localStorage\n    const saveToStorage = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((ratings)=>{\n        if (false) {}\n        try {\n            const ratingsArray = Array.from(ratings.entries());\n            localStorage.setItem(STORAGE_KEY, JSON.stringify(ratingsArray));\n        } catch (error) {\n            console.warn(\"Failed to save pending ratings to storage:\", error);\n        }\n    }, []);\n    // Clear storage\n    const clearStorage = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (false) {}\n        try {\n            localStorage.removeItem(STORAGE_KEY);\n        } catch (error) {\n            console.warn(\"Failed to clear pending ratings from storage:\", error);\n        }\n    }, []);\n    // Set a cached rating (will be saved to DB after debounce delay)\n    const setCachedRating = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((videoId, tagId, rating)=>{\n        if (!session) return;\n        const timestamp = new Date().toISOString().split(\"T\")[1].split(\".\")[0];\n        console.log(\"⭐ [\".concat(timestamp, \"] SETTING CACHED RATING: \").concat(videoId, \":\").concat(tagId, \" = \").concat(rating));\n        const key = getCacheKey(videoId, tagId);\n        const pendingRating = {\n            videoId,\n            tagId,\n            rating,\n            timestamp: Date.now()\n        };\n        setPendingRatings((prev)=>{\n            const newMap = new Map(prev);\n            newMap.set(key, pendingRating);\n            // Save to localStorage immediately\n            saveToStorage(newMap);\n            return newMap;\n        });\n        // Reset debounce timer\n        if (debounceTimer) {\n            console.log(\"⏰ Clearing existing timer for new rating: \".concat(videoId, \":\").concat(tagId));\n            clearTimeout(debounceTimer);\n        }\n        const newTimer = setTimeout(()=>{\n            console.log(\"⏰ Timer expired, flushing all pending ratings\");\n            // Use ref to avoid stale closure\n            if (flushPendingRatingsRef.current) {\n                flushPendingRatingsRef.current();\n            }\n        }, debounceDelay);\n        console.log(\"⏰ Set new timer for \".concat(debounceDelay, \"ms\"));\n        setDebounceTimer(newTimer);\n    }, [\n        session,\n        debounceTimer,\n        saveToStorage,\n        debounceDelay\n    ]);\n    // Get cached rating value\n    const getCachedRating = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((videoId, tagId)=>{\n        const key = getCacheKey(videoId, tagId);\n        const pending = pendingRatings.get(key);\n        if (pending) {\n            // Validate that the cached rating matches the requested video/tag\n            if (pending.videoId !== videoId || pending.tagId !== tagId) {\n                console.error(\"\\uD83D\\uDEA8 CACHED RATING MISMATCH: requested \".concat(videoId, \":\").concat(tagId, \", got \").concat(pending.videoId, \":\").concat(pending.tagId, \", removing corrupt cache entry\"));\n                // Remove the corrupt cache entry\n                const corruptedKey = key;\n                setPendingRatings((prev)=>{\n                    const cleaned = new Map(prev);\n                    cleaned.delete(corruptedKey);\n                    return cleaned;\n                });\n                return null;\n            }\n            console.log(\"\\uD83D\\uDCCA [\".concat(new Date().toISOString().split(\"T\")[1].split(\".\")[0], \"] Cache hit: \").concat(videoId, \":\").concat(tagId, \" = \").concat(pending.rating));\n            return pending.rating;\n        }\n        return null;\n    }, [\n        pendingRatings,\n        setPendingRatings\n    ]);\n    // Check if there's a pending rating\n    const hasPendingRating = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((videoId, tagId)=>{\n        const key = getCacheKey(videoId, tagId);\n        const rating = pendingRatings.get(key);\n        if (!rating) return false;\n        // Validate that the cached rating matches the requested video/tag\n        if (rating.videoId !== videoId || rating.tagId !== tagId) {\n            console.error(\"\\uD83D\\uDEA8 PENDING RATING MISMATCH: requested \".concat(videoId, \":\").concat(tagId, \", got \").concat(rating.videoId, \":\").concat(rating.tagId));\n            return false;\n        }\n        // Check if this is an expired \"saved\" rating\n        const now = Date.now();\n        if (rating.timestamp > now && rating.timestamp - now < 6000) {\n            // This is a saved rating that's temporarily kept to prevent visual revert\n            // Don't show it as pending since it's already saved\n            return false;\n        }\n        return true;\n    }, [\n        pendingRatings\n    ]);\n    // Flush all pending ratings to database using bulk API\n    const flushPendingRatings = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async ()=>{\n        if (pendingRatings.size === 0 || !session) return;\n        // Only flush actual pending ratings, not temporarily saved ones\n        const now = Date.now();\n        const actualPendingRatings = Array.from(pendingRatings.values()).filter((rating)=>rating.timestamp <= now // Normal pending ratings have past timestamps\n        );\n        console.log(\"\\uD83D\\uDD0D FLUSH ANALYSIS: Total cache entries=\".concat(pendingRatings.size, \", Actual pending=\").concat(actualPendingRatings.length));\n        actualPendingRatings.forEach((rating)=>{\n            console.log(\"   → \".concat(rating.videoId, \":\").concat(rating.tagId, \" = \").concat(rating.rating, \" (age: \").concat((now - rating.timestamp) / 1000, \"s)\"));\n        });\n        if (actualPendingRatings.length === 0) {\n            console.log(\"\\uD83D\\uDE80 No actual pending ratings to flush (only saved ones)\");\n            return;\n        }\n        console.log(\"\\uD83D\\uDE80 FLUSHING RATINGS:\", actualPendingRatings.length, \"actual pending ratings out of\", pendingRatings.size, \"total\");\n        const ratingsToSave = actualPendingRatings;\n        try {\n            var _result_data, _result_data1, _result_data2, _result_data3, _result_data_errors, _result_data4;\n            // Use bulk flush API for better performance\n            const response = await fetch(\"/api/ratings/flush\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                credentials: \"include\",\n                body: JSON.stringify(ratingsToSave.map((rating)=>({\n                        videoId: rating.videoId,\n                        tagId: rating.tagId,\n                        rating: rating.rating,\n                        timestamp: rating.timestamp\n                    })))\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || \"HTTP \".concat(response.status, \": Failed to flush ratings\"));\n            }\n            const result = await response.json();\n            // Add detailed API response logging\n            console.log(\"\\uD83D\\uDCE1 FULL API RESPONSE:\", JSON.stringify(result, null, 2));\n            console.log(\"\\uD83D\\uDCCA API Response Summary:\", {\n                success: result.success,\n                processed: (_result_data = result.data) === null || _result_data === void 0 ? void 0 : _result_data.processed,\n                successful: (_result_data1 = result.data) === null || _result_data1 === void 0 ? void 0 : _result_data1.successful,\n                failed: (_result_data2 = result.data) === null || _result_data2 === void 0 ? void 0 : _result_data2.failed,\n                hasErrors: !!(((_result_data3 = result.data) === null || _result_data3 === void 0 ? void 0 : _result_data3.errors) && result.data.errors.length > 0),\n                errorCount: ((_result_data4 = result.data) === null || _result_data4 === void 0 ? void 0 : (_result_data_errors = _result_data4.errors) === null || _result_data_errors === void 0 ? void 0 : _result_data_errors.length) || 0,\n                message: result.message,\n                error: result.error\n            });\n            if (!result.success) {\n                console.error(\"❌ API ERROR DETAILS:\", result);\n                throw new Error(result.message || \"Failed to save ratings\");\n            }\n            // Notify components that ratings were saved before clearing the cache\n            // Note: Removed automatic callback execution to prevent unwanted page refreshes\n            // Components can manually check for rating updates or use server-side caching instead\n            const { successful, failed, results, errors } = result.data;\n            // Only clear successfully saved ratings from cache\n            const successfulKeys = new Set();\n            const failedKeys = new Set();\n            // Process successful results\n            if (results && Array.isArray(results)) {\n                console.log(\"✅ Successfully saved ratings:\", results.length);\n                results.forEach((result)=>{\n                    const key = getCacheKey(result.videoId, result.tagId);\n                    console.log(\"✅ Success: \".concat(result.videoId, \":\").concat(result.tagId, \" (key: \").concat(key, \")\"));\n                    successfulKeys.add(key);\n                });\n            }\n            // Process failed results  \n            if (errors && Array.isArray(errors)) {\n                console.log(\"❌ Failed to save ratings:\", errors.length);\n                errors.forEach((error)=>{\n                    const key = getCacheKey(error.videoId, error.tagId);\n                    console.log(\"❌ Failed: \".concat(error.videoId, \":\").concat(error.tagId, \" - \").concat(error.error));\n                    failedKeys.add(key);\n                });\n            }\n            // Update pending ratings - keep successful ones as \"saved\" for a short time\n            // to prevent visual reversion until components get fresh data\n            const newPendingRatings = new Map();\n            console.log(\"\\uD83E\\uDDF9 Clearing cache: before =\", pendingRatings.size, \"successful =\", successfulKeys.size, \"failed =\", failedKeys.size);\n            pendingRatings.forEach((rating, key)=>{\n                const expectedKey = getCacheKey(rating.videoId, rating.tagId);\n                if (key !== expectedKey) {\n                    console.error(\"\\uD83D\\uDEA8 CACHE KEY MISMATCH: stored key=\".concat(key, \", expected=\").concat(expectedKey));\n                }\n                // Check if this specific rating was in the batch that was flushed\n                const wasInFlushBatch = ratingsToSave.some((flushedRating)=>flushedRating.videoId === rating.videoId && flushedRating.tagId === rating.tagId);\n                if (failedKeys.has(key)) {\n                    // Keep ratings that failed to save - they need to be retried\n                    console.log(\"\\uD83D\\uDD04 Keeping failed rating in cache: \".concat(rating.videoId, \":\").concat(rating.tagId));\n                    newPendingRatings.set(key, rating);\n                } else if (successfulKeys.has(key) && wasInFlushBatch) {\n                    // Only mark as temporarily saved if it was actually in the flush batch\n                    console.log(\"✅ Keeping successful rating temporarily: \".concat(rating.videoId, \":\").concat(rating.tagId));\n                    newPendingRatings.set(key, {\n                        ...rating,\n                        timestamp: Date.now() + 5000 // Mark as saved, will auto-expire in 5 seconds (longer to handle component re-renders)\n                    });\n                } else if (!wasInFlushBatch) {\n                    // This rating wasn't in the flush batch, so keep it as-is\n                    console.log(\"\\uD83D\\uDD04 Keeping unflushed rating: \".concat(rating.videoId, \":\").concat(rating.tagId));\n                    newPendingRatings.set(key, rating);\n                } else {\n                    console.log(\"⚠️ Rating not in success or fail list: \".concat(rating.videoId, \":\").concat(rating.tagId, \" (key: \").concat(key, \")\"));\n                    // Keep unknown ratings to be safe\n                    newPendingRatings.set(key, rating);\n                }\n            });\n            setPendingRatings(newPendingRatings);\n            // Update localStorage storage\n            if (newPendingRatings.size === 0) {\n                clearStorage();\n            } else {\n                saveToStorage(newPendingRatings);\n            }\n            // Clear debounce timer only if all ratings were processed\n            if (failed === 0 && debounceTimer) {\n                clearTimeout(debounceTimer);\n                setDebounceTimer(null);\n            }\n            // Log success with detailed info\n            console.log(\"Bulk rating flush completed: \".concat(successful, \" successful, \").concat(failed, \" failed out of \").concat(ratingsToSave.length, \" total\"));\n            if (failed > 0) {\n                console.warn(\"Some ratings failed to save:\", errors);\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_3__[\"default\"].error(\"\".concat(failed, \" ratings could not be saved. They will be retried automatically.\"));\n            }\n        } catch (error) {\n            console.error(\"Error flushing pending ratings:\", error);\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_3__[\"default\"].error(\"Some ratings could not be saved. Please try again.\");\n        // Don't clear cache on error - allow retry\n        }\n    }, [\n        pendingRatings,\n        session,\n        debounceTimer,\n        clearStorage\n    ]);\n    // Assign the function to the ref to avoid stale closure issues\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        flushPendingRatingsRef.current = flushPendingRatings;\n    }, [\n        flushPendingRatings\n    ]);\n    // Initialize from localStorage on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!isInitialized && session) {\n            const storedRatings = loadFromStorage();\n            if (storedRatings.size > 0) {\n                setPendingRatings(storedRatings);\n            // Disable immediate flush to prevent unwanted API calls on load\n            // setTimeout(async () => {\n            //   try {\n            //     await flushPendingRatings()\n            //     console.log('Successfully flushed pending ratings from localStorage')\n            //   } catch (error) {\n            //     console.error('Failed to flush ratings on load:', error)\n            //   }\n            // }, 100) // Very short delay just to ensure component is mounted\n            }\n            setIsInitialized(true);\n        }\n    }, [\n        session,\n        isInitialized,\n        loadFromStorage,\n        flushPendingRatings\n    ]);\n    // Clean up expired \"saved\" ratings periodically\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!isInitialized) return;\n        const cleanupInterval = setInterval(()=>{\n            const now = Date.now();\n            let hasExpiredRatings = false;\n            // Check for expired \"saved\" ratings (those with future timestamps that have passed)\n            for (const rating of Array.from(pendingRatings.values())){\n                if (rating.timestamp > now - 8000 && rating.timestamp <= now + 6000) {\n                    // This might be a saved rating that should be cleaned up\n                    hasExpiredRatings = true;\n                    break;\n                }\n            }\n            if (hasExpiredRatings) {\n                setPendingRatings((prev)=>{\n                    const cleaned = new Map();\n                    const currentTime = Date.now();\n                    prev.forEach((rating, key)=>{\n                        // Keep ratings that are either:\n                        // 1. Normal pending ratings (timestamp in the past)\n                        // 2. Saved ratings that haven't expired yet (timestamp > now + buffer)\n                        if (rating.timestamp <= currentTime || rating.timestamp > currentTime + 6000) {\n                            cleaned.set(key, rating);\n                        } else {\n                            console.log(\"\\uD83E\\uDDF9 Cleaning up expired saved rating: \".concat(rating.videoId, \":\").concat(rating.tagId));\n                        }\n                    });\n                    // Update localStorage if anything changed\n                    if (cleaned.size !== prev.size) {\n                        if (cleaned.size === 0) {\n                            clearStorage();\n                        } else {\n                            saveToStorage(cleaned);\n                        }\n                    }\n                    return cleaned.size !== prev.size ? cleaned : prev;\n                });\n            }\n        }, 1000) // Check every second for cleanup\n        ;\n        return ()=>clearInterval(cleanupInterval);\n    }, [\n        pendingRatings,\n        isInitialized,\n        clearStorage,\n        saveToStorage\n    ]);\n    // Flush on page unload/beforeunload\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!isInitialized) return;\n        const handleBeforeUnload = ()=>{\n            if (pendingRatings.size > 0) {\n                // Use sendBeacon for reliable data transmission during page unload\n                const ratingsData = Array.from(pendingRatings.values());\n                navigator.sendBeacon(\"/api/ratings/flush\", JSON.stringify(ratingsData));\n            }\n        };\n        const handleVisibilityChange = ()=>{\n            if (document.visibilityState === \"hidden\" && pendingRatings.size > 0) {\n                flushPendingRatings();\n            }\n        };\n        window.addEventListener(\"beforeunload\", handleBeforeUnload);\n        document.addEventListener(\"visibilitychange\", handleVisibilityChange);\n        return ()=>{\n            window.removeEventListener(\"beforeunload\", handleBeforeUnload);\n            document.removeEventListener(\"visibilitychange\", handleVisibilityChange);\n        };\n    }, [\n        pendingRatings,\n        flushPendingRatings,\n        isInitialized\n    ]);\n    // Cleanup timer on unmount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        return ()=>{\n            if (debounceTimer) {\n                clearTimeout(debounceTimer);\n            }\n        };\n    }, [\n        debounceTimer\n    ]);\n    // Removed rating saved callback functions to prevent unwanted page refreshes\n    // Set custom debounce delay\n    const setDebounceDelay = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((delay)=>{\n        const validatedDelay = Math.max(1000, Math.min(30000, delay)) // Between 1-30 seconds\n        ;\n        setDebounceDelayState(validatedDelay);\n        // Save to localStorage\n        if (true) {\n            try {\n                localStorage.setItem(DEBOUNCE_DELAY_KEY, validatedDelay.toString());\n            } catch (error) {\n                console.warn(\"Failed to save debounce delay to storage:\", error);\n            }\n        }\n    }, []);\n    // Get current debounce delay\n    const getDebounceDelay = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>debounceDelay, [\n        debounceDelay\n    ]);\n    // Get cache statistics\n    const getCacheStats = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        const ratings = Array.from(pendingRatings.values());\n        const oldestTimestamp = ratings.length > 0 ? Math.min(...ratings.map((r)=>r.timestamp)) : null;\n        return {\n            pendingCount: pendingRatings.size,\n            oldestTimestamp\n        };\n    }, [\n        pendingRatings\n    ]);\n    // Load debounce delay from storage on initialization\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (true) {\n            try {\n                const storedDelay = localStorage.getItem(DEBOUNCE_DELAY_KEY);\n                if (storedDelay) {\n                    const delay = parseInt(storedDelay, 10);\n                    if (!isNaN(delay) && delay >= 1000 && delay <= 30000) {\n                        setDebounceDelayState(delay);\n                    }\n                }\n            } catch (error) {\n                console.warn(\"Failed to load debounce delay from storage:\", error);\n            }\n        }\n    }, []);\n    const value = {\n        pendingRatings,\n        setCachedRating,\n        getCachedRating,\n        hasPendingRating,\n        flushPendingRatings,\n        setDebounceDelay,\n        getDebounceDelay,\n        getCacheStats\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(RatingCacheContext.Provider, {\n        value: value,\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/marcmongin/VSCodeProjects/RateMy/RateMy/contexts/RatingCacheContext.tsx\",\n        lineNumber: 523,\n        columnNumber: 5\n    }, this);\n}\n_s(RatingCacheProvider, \"seIRFq6XAempn8aQR5ApMyqqczE=\", false, function() {\n    return [\n        next_auth_react__WEBPACK_IMPORTED_MODULE_2__.useSession\n    ];\n});\n_c = RatingCacheProvider;\nfunction useRatingCache() {\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(RatingCacheContext);\n    if (context === undefined) {\n        throw new Error(\"useRatingCache must be used within a RatingCacheProvider\");\n    }\n    return context;\n}\n_s1(useRatingCache, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"RatingCacheProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbnRleHRzL1JhdGluZ0NhY2hlQ29udGV4dC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUVrRztBQUN0RDtBQUNUO0FBb0JuQyxNQUFNUyxtQ0FBcUJSLG9EQUFhQSxDQUFxQ1M7QUFFN0UsTUFBTUMseUJBQXlCLEtBQUssWUFBWTs7QUFDaEQsTUFBTUMsZ0JBQWdCLE1BQU0seUNBQXlDOztBQUNyRSxNQUFNQyxjQUFjO0FBQ3BCLE1BQU1DLHFCQUFxQjtBQUVwQixTQUFTQyxvQkFBb0IsS0FBMkM7UUFBM0MsRUFBRUMsUUFBUSxFQUFpQyxHQUEzQzs7SUFDbEMsTUFBTSxFQUFFQyxNQUFNQyxPQUFPLEVBQUUsR0FBR1gsMkRBQVVBO0lBQ3BDLE1BQU0sQ0FBQ1ksZ0JBQWdCQyxrQkFBa0IsR0FBR2pCLCtDQUFRQSxDQUE2QixJQUFJa0I7SUFDckYsTUFBTSxDQUFDQyxlQUFlQyxpQkFBaUIsR0FBR3BCLCtDQUFRQSxDQUF3QjtJQUMxRSxNQUFNLENBQUNxQixlQUFlQyxzQkFBc0IsR0FBR3RCLCtDQUFRQSxDQUFTUTtJQUNoRSxNQUFNLENBQUNlLGVBQWVDLGlCQUFpQixHQUFHeEIsK0NBQVFBLENBQUM7SUFFbkQseURBQXlEO0lBQ3pELE1BQU15Qix5QkFBeUJ0Qiw2Q0FBTUEsQ0FBK0I7SUFFcEUsa0NBQWtDO0lBQ2xDLE1BQU11QixjQUFjLENBQUNDLFNBQWlCQyxRQUFrQixHQUFjQSxPQUFYRCxTQUFRLEtBQVMsT0FBTkM7SUFFdEUseUNBQXlDO0lBQ3pDLE1BQU1DLGtCQUFrQjNCLGtEQUFXQSxDQUFDO1FBQ2xDLElBQUksS0FBa0IsRUFBYSxFQUFXZ0I7UUFFOUMsSUFBSTtZQUNGLE1BQU1ZLFNBQVNDLGFBQWFDLE9BQU8sQ0FBQ3RCO1lBQ3BDLElBQUksQ0FBQ29CLFFBQVEsT0FBTyxJQUFJWjtZQUV4QixNQUFNZSxTQUFTQyxLQUFLQyxLQUFLLENBQUNMO1lBQzFCLE1BQU1NLGFBQWEsSUFBSWxCLElBQUllO1lBRTNCLHlCQUF5QjtZQUN6QixNQUFNSSxNQUFNQyxLQUFLRCxHQUFHO1lBQ3BCLE1BQU1FLGNBQWMsSUFBSXJCO1lBQ3hCa0IsV0FBV0ksT0FBTyxDQUFDLENBQUNDLFFBQVFDO2dCQUMxQixJQUFJTCxNQUFNSSxPQUFPRSxTQUFTLElBQUlsQyxlQUFlO29CQUMzQzhCLFlBQVlLLEdBQUcsQ0FBQ0YsS0FBS0Q7Z0JBQ3ZCO1lBQ0Y7WUFFQSxPQUFPRjtRQUNULEVBQUUsT0FBT00sT0FBTztZQUNkQyxRQUFRQyxJQUFJLENBQUMsZ0RBQWdERjtZQUM3RCxPQUFPLElBQUkzQjtRQUNiO0lBQ0YsR0FBRyxFQUFFO0lBRUwsdUNBQXVDO0lBQ3ZDLE1BQU04QixnQkFBZ0I5QyxrREFBV0EsQ0FBQyxDQUFDK0M7UUFDakMsSUFBSSxLQUFrQixFQUFhO1FBRW5DLElBQUk7WUFDRixNQUFNQyxlQUFlQyxNQUFNQyxJQUFJLENBQUNILFFBQVFJLE9BQU87WUFDL0N0QixhQUFhdUIsT0FBTyxDQUFDNUMsYUFBYXdCLEtBQUtxQixTQUFTLENBQUNMO1FBQ25ELEVBQUUsT0FBT0wsT0FBTztZQUNkQyxRQUFRQyxJQUFJLENBQUMsOENBQThDRjtRQUM3RDtJQUNGLEdBQUcsRUFBRTtJQUVMLGdCQUFnQjtJQUNoQixNQUFNVyxlQUFldEQsa0RBQVdBLENBQUM7UUFDL0IsSUFBSSxLQUFrQixFQUFhO1FBRW5DLElBQUk7WUFDRjZCLGFBQWEwQixVQUFVLENBQUMvQztRQUMxQixFQUFFLE9BQU9tQyxPQUFPO1lBQ2RDLFFBQVFDLElBQUksQ0FBQyxpREFBaURGO1FBQ2hFO0lBQ0YsR0FBRyxFQUFFO0lBRUwsaUVBQWlFO0lBQ2pFLE1BQU1hLGtCQUFrQnhELGtEQUFXQSxDQUFDLENBQUN5QixTQUFpQkMsT0FBZWE7UUFDbkUsSUFBSSxDQUFDMUIsU0FBUztRQUVkLE1BQU00QixZQUFZLElBQUlMLE9BQU9xQixXQUFXLEdBQUdDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDQSxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDdEVkLFFBQVFlLEdBQUcsQ0FBQyxNQUEyQ2xDLE9BQXJDZ0IsV0FBVSw2QkFBc0NmLE9BQVhELFNBQVEsS0FBY2MsT0FBWGIsT0FBTSxPQUFZLE9BQVBhO1FBQzdFLE1BQU1DLE1BQU1oQixZQUFZQyxTQUFTQztRQUNqQyxNQUFNa0MsZ0JBQStCO1lBQ25DbkM7WUFDQUM7WUFDQWE7WUFDQUUsV0FBV0wsS0FBS0QsR0FBRztRQUNyQjtRQUVBcEIsa0JBQWtCOEMsQ0FBQUE7WUFDaEIsTUFBTUMsU0FBUyxJQUFJOUMsSUFBSTZDO1lBQ3ZCQyxPQUFPcEIsR0FBRyxDQUFDRixLQUFLb0I7WUFFaEIsbUNBQW1DO1lBQ25DZCxjQUFjZ0I7WUFFZCxPQUFPQTtRQUNUO1FBRUEsdUJBQXVCO1FBQ3ZCLElBQUk3QyxlQUFlO1lBQ2pCMkIsUUFBUWUsR0FBRyxDQUFDLDZDQUF3RGpDLE9BQVhELFNBQVEsS0FBUyxPQUFOQztZQUNwRXFDLGFBQWE5QztRQUNmO1FBRUEsTUFBTStDLFdBQVdDLFdBQVc7WUFDMUJyQixRQUFRZSxHQUFHLENBQUU7WUFDYixpQ0FBaUM7WUFDakMsSUFBSXBDLHVCQUF1QjJDLE9BQU8sRUFBRTtnQkFDbEMzQyx1QkFBdUIyQyxPQUFPO1lBQ2hDO1FBQ0YsR0FBRy9DO1FBRUh5QixRQUFRZSxHQUFHLENBQUMsdUJBQXFDLE9BQWR4QyxlQUFjO1FBQ2pERCxpQkFBaUI4QztJQUNuQixHQUFHO1FBQUNuRDtRQUFTSTtRQUFlNkI7UUFBZTNCO0tBQWM7SUFFekQsMEJBQTBCO0lBQzFCLE1BQU1nRCxrQkFBa0JuRSxrREFBV0EsQ0FBQyxDQUFDeUIsU0FBaUJDO1FBQ3BELE1BQU1jLE1BQU1oQixZQUFZQyxTQUFTQztRQUNqQyxNQUFNMEMsVUFBVXRELGVBQWV1RCxHQUFHLENBQUM3QjtRQUVuQyxJQUFJNEIsU0FBUztZQUNYLGtFQUFrRTtZQUNsRSxJQUFJQSxRQUFRM0MsT0FBTyxLQUFLQSxXQUFXMkMsUUFBUTFDLEtBQUssS0FBS0EsT0FBTztnQkFDMURrQixRQUFRRCxLQUFLLENBQUMsa0RBQW1EakIsT0FBWEQsU0FBUSxLQUFpQjJDLE9BQWQxQyxPQUFNLFVBQTJCMEMsT0FBbkJBLFFBQVEzQyxPQUFPLEVBQUMsS0FBaUIsT0FBZDJDLFFBQVExQyxLQUFLLEVBQUM7Z0JBQ2hILGlDQUFpQztnQkFDakMsTUFBTTRDLGVBQWU5QjtnQkFDckJ6QixrQkFBa0I4QyxDQUFBQTtvQkFDaEIsTUFBTVUsVUFBVSxJQUFJdkQsSUFBSTZDO29CQUN4QlUsUUFBUUMsTUFBTSxDQUFDRjtvQkFDZixPQUFPQztnQkFDVDtnQkFDQSxPQUFPO1lBQ1Q7WUFDQTNCLFFBQVFlLEdBQUcsQ0FBQyxpQkFBMkVsQyxPQUFwRSxJQUFJVyxPQUFPcUIsV0FBVyxHQUFHQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQ0EsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUMsaUJBQTBCaEMsT0FBWEQsU0FBUSxLQUFjMkMsT0FBWDFDLE9BQU0sT0FBb0IsT0FBZjBDLFFBQVE3QixNQUFNO1lBQzNILE9BQU82QixRQUFRN0IsTUFBTTtRQUN2QjtRQUVBLE9BQU87SUFDVCxHQUFHO1FBQUN6QjtRQUFnQkM7S0FBa0I7SUFFdEMsb0NBQW9DO0lBQ3BDLE1BQU0wRCxtQkFBbUJ6RSxrREFBV0EsQ0FBQyxDQUFDeUIsU0FBaUJDO1FBQ3JELE1BQU1jLE1BQU1oQixZQUFZQyxTQUFTQztRQUNqQyxNQUFNYSxTQUFTekIsZUFBZXVELEdBQUcsQ0FBQzdCO1FBQ2xDLElBQUksQ0FBQ0QsUUFBUSxPQUFPO1FBRXBCLGtFQUFrRTtRQUNsRSxJQUFJQSxPQUFPZCxPQUFPLEtBQUtBLFdBQVdjLE9BQU9iLEtBQUssS0FBS0EsT0FBTztZQUN4RGtCLFFBQVFELEtBQUssQ0FBQyxtREFBb0RqQixPQUFYRCxTQUFRLEtBQWlCYyxPQUFkYixPQUFNLFVBQTBCYSxPQUFsQkEsT0FBT2QsT0FBTyxFQUFDLEtBQWdCLE9BQWJjLE9BQU9iLEtBQUs7WUFDOUcsT0FBTztRQUNUO1FBRUEsNkNBQTZDO1FBQzdDLE1BQU1TLE1BQU1DLEtBQUtELEdBQUc7UUFDcEIsSUFBSUksT0FBT0UsU0FBUyxHQUFHTixPQUFPSSxPQUFPRSxTQUFTLEdBQUdOLE1BQU0sTUFBTTtZQUMzRCwwRUFBMEU7WUFDMUUsb0RBQW9EO1lBQ3BELE9BQU87UUFDVDtRQUVBLE9BQU87SUFDVCxHQUFHO1FBQUNyQjtLQUFlO0lBRW5CLHVEQUF1RDtJQUN2RCxNQUFNNEQsc0JBQXNCMUUsa0RBQVdBLENBQUM7UUFDdEMsSUFBSWMsZUFBZTZELElBQUksS0FBSyxLQUFLLENBQUM5RCxTQUFTO1FBRTNDLGdFQUFnRTtRQUNoRSxNQUFNc0IsTUFBTUMsS0FBS0QsR0FBRztRQUNwQixNQUFNeUMsdUJBQXVCM0IsTUFBTUMsSUFBSSxDQUFDcEMsZUFBZStELE1BQU0sSUFBSUMsTUFBTSxDQUFDdkMsQ0FBQUEsU0FDdEVBLE9BQU9FLFNBQVMsSUFBSU4sSUFBSSw4Q0FBOEM7O1FBR3hFUyxRQUFRZSxHQUFHLENBQUMsb0RBQWlGaUIsT0FBdkM5RCxlQUFlNkQsSUFBSSxFQUFDLHFCQUErQyxPQUE1QkMscUJBQXFCRyxNQUFNO1FBQ3hISCxxQkFBcUJ0QyxPQUFPLENBQUNDLENBQUFBO1lBQzNCSyxRQUFRZSxHQUFHLENBQUMsUUFBMEJwQixPQUFsQkEsT0FBT2QsT0FBTyxFQUFDLEtBQXFCYyxPQUFsQkEsT0FBT2IsS0FBSyxFQUFDLE9BQTRCLE9BQXZCYSxPQUFPQSxNQUFNLEVBQUMsV0FBdUMsT0FBOUIsQ0FBQ0osTUFBTUksT0FBT0UsU0FBUyxJQUFFLE1BQUs7UUFDL0c7UUFFQSxJQUFJbUMscUJBQXFCRyxNQUFNLEtBQUssR0FBRztZQUNyQ25DLFFBQVFlLEdBQUcsQ0FBQztZQUNaO1FBQ0Y7UUFFQWYsUUFBUWUsR0FBRyxDQUFDLGtDQUF3QmlCLHFCQUFxQkcsTUFBTSxFQUFFLGlDQUFpQ2pFLGVBQWU2RCxJQUFJLEVBQUU7UUFDdkgsTUFBTUssZ0JBQWdCSjtRQUV0QixJQUFJO2dCQTJCV0ssY0FDQ0EsZUFDSkEsZUFDTUEsZUFDRkEscUJBQUFBO1lBOUJkLDRDQUE0QztZQUM1QyxNQUFNQyxXQUFXLE1BQU1DLE1BQU0sc0JBQXNCO2dCQUNqREMsUUFBUTtnQkFDUkMsU0FBUztvQkFDUCxnQkFBZ0I7Z0JBQ2xCO2dCQUNBQyxhQUFhO2dCQUNiQyxNQUFNdkQsS0FBS3FCLFNBQVMsQ0FBQzJCLGNBQWNRLEdBQUcsQ0FBQ2pELENBQUFBLFNBQVc7d0JBQ2hEZCxTQUFTYyxPQUFPZCxPQUFPO3dCQUN2QkMsT0FBT2EsT0FBT2IsS0FBSzt3QkFDbkJhLFFBQVFBLE9BQU9BLE1BQU07d0JBQ3JCRSxXQUFXRixPQUFPRSxTQUFTO29CQUM3QjtZQUNGO1lBRUEsSUFBSSxDQUFDeUMsU0FBU08sRUFBRSxFQUFFO2dCQUNoQixNQUFNQyxZQUFZLE1BQU1SLFNBQVNTLElBQUksR0FBR0MsS0FBSyxDQUFDLElBQU8sRUFBQztnQkFDdEQsTUFBTSxJQUFJQyxNQUFNSCxVQUFVSSxPQUFPLElBQUksUUFBd0IsT0FBaEJaLFNBQVNhLE1BQU0sRUFBQztZQUMvRDtZQUVBLE1BQU1kLFNBQVMsTUFBTUMsU0FBU1MsSUFBSTtZQUVsQyxvQ0FBb0M7WUFDcEMvQyxRQUFRZSxHQUFHLENBQUMsbUNBQXlCM0IsS0FBS3FCLFNBQVMsQ0FBQzRCLFFBQVEsTUFBTTtZQUNsRXJDLFFBQVFlLEdBQUcsQ0FBQyxzQ0FBNEI7Z0JBQ3RDcUMsU0FBU2YsT0FBT2UsT0FBTztnQkFDdkJDLFNBQVMsR0FBRWhCLGVBQUFBLE9BQU9yRSxJQUFJLGNBQVhxRSxtQ0FBQUEsYUFBYWdCLFNBQVM7Z0JBQ2pDQyxVQUFVLEdBQUVqQixnQkFBQUEsT0FBT3JFLElBQUksY0FBWHFFLG9DQUFBQSxjQUFhaUIsVUFBVTtnQkFDbkNDLE1BQU0sR0FBRWxCLGdCQUFBQSxPQUFPckUsSUFBSSxjQUFYcUUsb0NBQUFBLGNBQWFrQixNQUFNO2dCQUMzQkMsV0FBVyxDQUFDLENBQUVuQixDQUFBQSxFQUFBQSxnQkFBQUEsT0FBT3JFLElBQUksY0FBWHFFLG9DQUFBQSxjQUFhb0IsTUFBTSxLQUFJcEIsT0FBT3JFLElBQUksQ0FBQ3lGLE1BQU0sQ0FBQ3RCLE1BQU0sR0FBRztnQkFDakV1QixZQUFZckIsRUFBQUEsZ0JBQUFBLE9BQU9yRSxJQUFJLGNBQVhxRSxxQ0FBQUEsc0JBQUFBLGNBQWFvQixNQUFNLGNBQW5CcEIsMENBQUFBLG9CQUFxQkYsTUFBTSxLQUFJO2dCQUMzQ2UsU0FBU2IsT0FBT2EsT0FBTztnQkFDdkJuRCxPQUFPc0MsT0FBT3RDLEtBQUs7WUFDckI7WUFFQSxJQUFJLENBQUNzQyxPQUFPZSxPQUFPLEVBQUU7Z0JBQ25CcEQsUUFBUUQsS0FBSyxDQUFDLHdCQUF3QnNDO2dCQUN0QyxNQUFNLElBQUlZLE1BQU1aLE9BQU9hLE9BQU8sSUFBSTtZQUNwQztZQUVBLHNFQUFzRTtZQUN0RSxnRkFBZ0Y7WUFDaEYsc0ZBQXNGO1lBRXRGLE1BQU0sRUFBRUksVUFBVSxFQUFFQyxNQUFNLEVBQUVJLE9BQU8sRUFBRUYsTUFBTSxFQUFFLEdBQUdwQixPQUFPckUsSUFBSTtZQUUzRCxtREFBbUQ7WUFDbkQsTUFBTTRGLGlCQUFpQixJQUFJQztZQUMzQixNQUFNQyxhQUFhLElBQUlEO1lBRXZCLDZCQUE2QjtZQUM3QixJQUFJRixXQUFXdEQsTUFBTTBELE9BQU8sQ0FBQ0osVUFBVTtnQkFDckMzRCxRQUFRZSxHQUFHLENBQUMsaUNBQWlDNEMsUUFBUXhCLE1BQU07Z0JBQzNEd0IsUUFBUWpFLE9BQU8sQ0FBQyxDQUFDMkM7b0JBQ2YsTUFBTXpDLE1BQU1oQixZQUFZeUQsT0FBT3hELE9BQU8sRUFBRXdELE9BQU92RCxLQUFLO29CQUNwRGtCLFFBQVFlLEdBQUcsQ0FBQyxjQUFnQ3NCLE9BQWxCQSxPQUFPeEQsT0FBTyxFQUFDLEtBQXlCZSxPQUF0QnlDLE9BQU92RCxLQUFLLEVBQUMsV0FBYSxPQUFKYyxLQUFJO29CQUN0RWdFLGVBQWVJLEdBQUcsQ0FBQ3BFO2dCQUNyQjtZQUNGO1lBRUEsMkJBQTJCO1lBQzNCLElBQUk2RCxVQUFVcEQsTUFBTTBELE9BQU8sQ0FBQ04sU0FBUztnQkFDbkN6RCxRQUFRZSxHQUFHLENBQUMsNkJBQTZCMEMsT0FBT3RCLE1BQU07Z0JBQ3REc0IsT0FBTy9ELE9BQU8sQ0FBQyxDQUFDSztvQkFDZCxNQUFNSCxNQUFNaEIsWUFBWW1CLE1BQU1sQixPQUFPLEVBQUVrQixNQUFNakIsS0FBSztvQkFDbERrQixRQUFRZSxHQUFHLENBQUMsYUFBOEJoQixPQUFqQkEsTUFBTWxCLE9BQU8sRUFBQyxLQUFvQmtCLE9BQWpCQSxNQUFNakIsS0FBSyxFQUFDLE9BQWlCLE9BQVppQixNQUFNQSxLQUFLO29CQUN0RStELFdBQVdFLEdBQUcsQ0FBQ3BFO2dCQUNqQjtZQUNGO1lBRUEsNEVBQTRFO1lBQzVFLDhEQUE4RDtZQUM5RCxNQUFNcUUsb0JBQW9CLElBQUk3RjtZQUU5QjRCLFFBQVFlLEdBQUcsQ0FBQyx5Q0FBK0I3QyxlQUFlNkQsSUFBSSxFQUFFLGdCQUFnQjZCLGVBQWU3QixJQUFJLEVBQUUsWUFBWStCLFdBQVcvQixJQUFJO1lBRWhJN0QsZUFBZXdCLE9BQU8sQ0FBQyxDQUFDQyxRQUFRQztnQkFDOUIsTUFBTXNFLGNBQWN0RixZQUFZZSxPQUFPZCxPQUFPLEVBQUVjLE9BQU9iLEtBQUs7Z0JBQzVELElBQUljLFFBQVFzRSxhQUFhO29CQUN2QmxFLFFBQVFELEtBQUssQ0FBQywrQ0FBc0RtRSxPQUFqQnRFLEtBQUksZUFBeUIsT0FBWnNFO2dCQUN0RTtnQkFFQSxrRUFBa0U7Z0JBQ2xFLE1BQU1DLGtCQUFrQi9CLGNBQWNnQyxJQUFJLENBQUNDLENBQUFBLGdCQUN6Q0EsY0FBY3hGLE9BQU8sS0FBS2MsT0FBT2QsT0FBTyxJQUFJd0YsY0FBY3ZGLEtBQUssS0FBS2EsT0FBT2IsS0FBSztnQkFHbEYsSUFBSWdGLFdBQVdRLEdBQUcsQ0FBQzFFLE1BQU07b0JBQ3ZCLDZEQUE2RDtvQkFDN0RJLFFBQVFlLEdBQUcsQ0FBQyxnREFBd0RwQixPQUFsQkEsT0FBT2QsT0FBTyxFQUFDLEtBQWdCLE9BQWJjLE9BQU9iLEtBQUs7b0JBQ2hGbUYsa0JBQWtCbkUsR0FBRyxDQUFDRixLQUFLRDtnQkFDN0IsT0FBTyxJQUFJaUUsZUFBZVUsR0FBRyxDQUFDMUUsUUFBUXVFLGlCQUFpQjtvQkFDckQsdUVBQXVFO29CQUN2RW5FLFFBQVFlLEdBQUcsQ0FBQyw0Q0FBOERwQixPQUFsQkEsT0FBT2QsT0FBTyxFQUFDLEtBQWdCLE9BQWJjLE9BQU9iLEtBQUs7b0JBQ3RGbUYsa0JBQWtCbkUsR0FBRyxDQUFDRixLQUFLO3dCQUN6QixHQUFHRCxNQUFNO3dCQUNURSxXQUFXTCxLQUFLRCxHQUFHLEtBQUssS0FBSyx1RkFBdUY7b0JBQ3RIO2dCQUNGLE9BQU8sSUFBSSxDQUFDNEUsaUJBQWlCO29CQUMzQiwwREFBMEQ7b0JBQzFEbkUsUUFBUWUsR0FBRyxDQUFDLDBDQUFrRHBCLE9BQWxCQSxPQUFPZCxPQUFPLEVBQUMsS0FBZ0IsT0FBYmMsT0FBT2IsS0FBSztvQkFDMUVtRixrQkFBa0JuRSxHQUFHLENBQUNGLEtBQUtEO2dCQUM3QixPQUFPO29CQUNMSyxRQUFRZSxHQUFHLENBQUMsMENBQTREcEIsT0FBbEJBLE9BQU9kLE9BQU8sRUFBQyxLQUF5QmUsT0FBdEJELE9BQU9iLEtBQUssRUFBQyxXQUFhLE9BQUpjLEtBQUk7b0JBQ2xHLGtDQUFrQztvQkFDbENxRSxrQkFBa0JuRSxHQUFHLENBQUNGLEtBQUtEO2dCQUM3QjtZQUNGO1lBRUF4QixrQkFBa0I4RjtZQUVsQiw4QkFBOEI7WUFDOUIsSUFBSUEsa0JBQWtCbEMsSUFBSSxLQUFLLEdBQUc7Z0JBQ2hDckI7WUFDRixPQUFPO2dCQUNMUixjQUFjK0Q7WUFDaEI7WUFFQSwwREFBMEQ7WUFDMUQsSUFBSVYsV0FBVyxLQUFLbEYsZUFBZTtnQkFDakM4QyxhQUFhOUM7Z0JBQ2JDLGlCQUFpQjtZQUNuQjtZQUVBLGlDQUFpQztZQUNqQzBCLFFBQVFlLEdBQUcsQ0FBQyxnQ0FBMER3QyxPQUExQkQsWUFBVyxpQkFBdUNsQixPQUF4Qm1CLFFBQU8sbUJBQXNDLE9BQXJCbkIsY0FBY0QsTUFBTSxFQUFDO1lBRW5ILElBQUlvQixTQUFTLEdBQUc7Z0JBQ2R2RCxRQUFRQyxJQUFJLENBQUMsZ0NBQWdDd0Q7Z0JBQzdDbEcsdURBQUtBLENBQUN3QyxLQUFLLENBQUMsR0FBVSxPQUFQd0QsUUFBTztZQUN4QjtRQUVGLEVBQUUsT0FBT3hELE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLG1DQUFtQ0E7WUFDakR4Qyx1REFBS0EsQ0FBQ3dDLEtBQUssQ0FBQztRQUVaLDJDQUEyQztRQUM3QztJQUNGLEdBQUc7UUFBQzdCO1FBQWdCRDtRQUFTSTtRQUFlcUM7S0FBYTtJQUV6RCwrREFBK0Q7SUFDL0R2RCxnREFBU0EsQ0FBQztRQUNSd0IsdUJBQXVCMkMsT0FBTyxHQUFHUTtJQUNuQyxHQUFHO1FBQUNBO0tBQW9CO0lBRXhCLHdDQUF3QztJQUN4QzNFLGdEQUFTQSxDQUFDO1FBQ1IsSUFBSSxDQUFDc0IsaUJBQWlCUixTQUFTO1lBQzdCLE1BQU1zRyxnQkFBZ0J4RjtZQUN0QixJQUFJd0YsY0FBY3hDLElBQUksR0FBRyxHQUFHO2dCQUMxQjVELGtCQUFrQm9HO1lBRWxCLGdFQUFnRTtZQUNoRSwyQkFBMkI7WUFDM0IsVUFBVTtZQUNWLGtDQUFrQztZQUNsQyw0RUFBNEU7WUFDNUUsc0JBQXNCO1lBQ3RCLCtEQUErRDtZQUMvRCxNQUFNO1lBQ04sa0VBQWtFO1lBQ3BFO1lBQ0E3RixpQkFBaUI7UUFDbkI7SUFDRixHQUFHO1FBQUNUO1FBQVNRO1FBQWVNO1FBQWlCK0M7S0FBb0I7SUFFakUsZ0RBQWdEO0lBQ2hEM0UsZ0RBQVNBLENBQUM7UUFDUixJQUFJLENBQUNzQixlQUFlO1FBRXBCLE1BQU0rRixrQkFBa0JDLFlBQVk7WUFDbEMsTUFBTWxGLE1BQU1DLEtBQUtELEdBQUc7WUFDcEIsSUFBSW1GLG9CQUFvQjtZQUV4QixvRkFBb0Y7WUFDcEYsS0FBSyxNQUFNL0UsVUFBVVUsTUFBTUMsSUFBSSxDQUFDcEMsZUFBZStELE1BQU0sSUFBSztnQkFDeEQsSUFBSXRDLE9BQU9FLFNBQVMsR0FBR04sTUFBTSxRQUFRSSxPQUFPRSxTQUFTLElBQUlOLE1BQU0sTUFBTTtvQkFDbkUseURBQXlEO29CQUN6RG1GLG9CQUFvQjtvQkFDcEI7Z0JBQ0Y7WUFDRjtZQUVBLElBQUlBLG1CQUFtQjtnQkFDckJ2RyxrQkFBa0I4QyxDQUFBQTtvQkFDaEIsTUFBTVUsVUFBVSxJQUFJdkQ7b0JBQ3BCLE1BQU11RyxjQUFjbkYsS0FBS0QsR0FBRztvQkFFNUIwQixLQUFLdkIsT0FBTyxDQUFDLENBQUNDLFFBQVFDO3dCQUNwQixnQ0FBZ0M7d0JBQ2hDLG9EQUFvRDt3QkFDcEQsdUVBQXVFO3dCQUN2RSxJQUFJRCxPQUFPRSxTQUFTLElBQUk4RSxlQUFlaEYsT0FBT0UsU0FBUyxHQUFHOEUsY0FBYyxNQUFNOzRCQUM1RWhELFFBQVE3QixHQUFHLENBQUNGLEtBQUtEO3dCQUNuQixPQUFPOzRCQUNMSyxRQUFRZSxHQUFHLENBQUMsa0RBQTBEcEIsT0FBbEJBLE9BQU9kLE9BQU8sRUFBQyxLQUFnQixPQUFiYyxPQUFPYixLQUFLO3dCQUNwRjtvQkFDRjtvQkFFQSwwQ0FBMEM7b0JBQzFDLElBQUk2QyxRQUFRSSxJQUFJLEtBQUtkLEtBQUtjLElBQUksRUFBRTt3QkFDOUIsSUFBSUosUUFBUUksSUFBSSxLQUFLLEdBQUc7NEJBQ3RCckI7d0JBQ0YsT0FBTzs0QkFDTFIsY0FBY3lCO3dCQUNoQjtvQkFDRjtvQkFFQSxPQUFPQSxRQUFRSSxJQUFJLEtBQUtkLEtBQUtjLElBQUksR0FBR0osVUFBVVY7Z0JBQ2hEO1lBQ0Y7UUFDRixHQUFHLE1BQU0saUNBQWlDOztRQUUxQyxPQUFPLElBQU0yRCxjQUFjSjtJQUM3QixHQUFHO1FBQUN0RztRQUFnQk87UUFBZWlDO1FBQWNSO0tBQWM7SUFFL0Qsb0NBQW9DO0lBQ3BDL0MsZ0RBQVNBLENBQUM7UUFDUixJQUFJLENBQUNzQixlQUFlO1FBRXBCLE1BQU1vRyxxQkFBcUI7WUFDekIsSUFBSTNHLGVBQWU2RCxJQUFJLEdBQUcsR0FBRztnQkFDM0IsbUVBQW1FO2dCQUNuRSxNQUFNK0MsY0FBY3pFLE1BQU1DLElBQUksQ0FBQ3BDLGVBQWUrRCxNQUFNO2dCQUNwRDhDLFVBQVVDLFVBQVUsQ0FBQyxzQkFBc0I1RixLQUFLcUIsU0FBUyxDQUFDcUU7WUFDNUQ7UUFDRjtRQUVBLE1BQU1HLHlCQUF5QjtZQUM3QixJQUFJQyxTQUFTQyxlQUFlLEtBQUssWUFBWWpILGVBQWU2RCxJQUFJLEdBQUcsR0FBRztnQkFDcEVEO1lBQ0Y7UUFDRjtRQUVBc0QsT0FBT0MsZ0JBQWdCLENBQUMsZ0JBQWdCUjtRQUN4Q0ssU0FBU0csZ0JBQWdCLENBQUMsb0JBQW9CSjtRQUU5QyxPQUFPO1lBQ0xHLE9BQU9FLG1CQUFtQixDQUFDLGdCQUFnQlQ7WUFDM0NLLFNBQVNJLG1CQUFtQixDQUFDLG9CQUFvQkw7UUFDbkQ7SUFDRixHQUFHO1FBQUMvRztRQUFnQjREO1FBQXFCckQ7S0FBYztJQUV2RCwyQkFBMkI7SUFDM0J0QixnREFBU0EsQ0FBQztRQUNSLE9BQU87WUFDTCxJQUFJa0IsZUFBZTtnQkFDakI4QyxhQUFhOUM7WUFDZjtRQUNGO0lBQ0YsR0FBRztRQUFDQTtLQUFjO0lBRWxCLDZFQUE2RTtJQUU3RSw0QkFBNEI7SUFDNUIsTUFBTWtILG1CQUFtQm5JLGtEQUFXQSxDQUFDLENBQUNvSTtRQUNwQyxNQUFNQyxpQkFBaUJDLEtBQUtDLEdBQUcsQ0FBQyxNQUFNRCxLQUFLRSxHQUFHLENBQUMsT0FBT0osUUFBUSx1QkFBdUI7O1FBQ3JGaEgsc0JBQXNCaUg7UUFFdEIsdUJBQXVCO1FBQ3ZCLElBQUksSUFBa0IsRUFBYTtZQUNqQyxJQUFJO2dCQUNGeEcsYUFBYXVCLE9BQU8sQ0FBQzNDLG9CQUFvQjRILGVBQWVJLFFBQVE7WUFDbEUsRUFBRSxPQUFPOUYsT0FBTztnQkFDZEMsUUFBUUMsSUFBSSxDQUFDLDZDQUE2Q0Y7WUFDNUQ7UUFDRjtJQUNGLEdBQUcsRUFBRTtJQUVMLDZCQUE2QjtJQUM3QixNQUFNK0YsbUJBQW1CMUksa0RBQVdBLENBQUMsSUFBTW1CLGVBQWU7UUFBQ0E7S0FBYztJQUV6RSx1QkFBdUI7SUFDdkIsTUFBTXdILGdCQUFnQjNJLGtEQUFXQSxDQUFDO1FBQ2hDLE1BQU0rQyxVQUFVRSxNQUFNQyxJQUFJLENBQUNwQyxlQUFlK0QsTUFBTTtRQUNoRCxNQUFNK0Qsa0JBQWtCN0YsUUFBUWdDLE1BQU0sR0FBRyxJQUNyQ3VELEtBQUtFLEdBQUcsSUFBSXpGLFFBQVF5QyxHQUFHLENBQUNxRCxDQUFBQSxJQUFLQSxFQUFFcEcsU0FBUyxLQUN4QztRQUVKLE9BQU87WUFDTHFHLGNBQWNoSSxlQUFlNkQsSUFBSTtZQUNqQ2lFO1FBQ0Y7SUFDRixHQUFHO1FBQUM5SDtLQUFlO0lBRW5CLHFEQUFxRDtJQUNyRGYsZ0RBQVNBLENBQUM7UUFDUixJQUFJLElBQWtCLEVBQWE7WUFDakMsSUFBSTtnQkFDRixNQUFNZ0osY0FBY2xILGFBQWFDLE9BQU8sQ0FBQ3JCO2dCQUN6QyxJQUFJc0ksYUFBYTtvQkFDZixNQUFNWCxRQUFRWSxTQUFTRCxhQUFhO29CQUNwQyxJQUFJLENBQUNFLE1BQU1iLFVBQVVBLFNBQVMsUUFBUUEsU0FBUyxPQUFPO3dCQUNwRGhILHNCQUFzQmdIO29CQUN4QjtnQkFDRjtZQUNGLEVBQUUsT0FBT3pGLE9BQU87Z0JBQ2RDLFFBQVFDLElBQUksQ0FBQywrQ0FBK0NGO1lBQzlEO1FBQ0Y7SUFDRixHQUFHLEVBQUU7SUFFTCxNQUFNdUcsUUFBZ0M7UUFDcENwSTtRQUNBMEM7UUFDQVc7UUFDQU07UUFDQUM7UUFDQXlEO1FBQ0FPO1FBQ0FDO0lBQ0Y7SUFFQSxxQkFDRSw4REFBQ3ZJLG1CQUFtQitJLFFBQVE7UUFBQ0QsT0FBT0E7a0JBQ2pDdkk7Ozs7OztBQUdQO0dBL2VnQkQ7O1FBQ1lSLHVEQUFVQTs7O0tBRHRCUTtBQWlmVCxTQUFTMEk7O0lBQ2QsTUFBTUMsVUFBVXhKLGlEQUFVQSxDQUFDTztJQUMzQixJQUFJaUosWUFBWWhKLFdBQVc7UUFDekIsTUFBTSxJQUFJd0YsTUFBTTtJQUNsQjtJQUNBLE9BQU93RDtBQUNUO0lBTmdCRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb250ZXh0cy9SYXRpbmdDYWNoZUNvbnRleHQudHN4P2U3YzUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCBSZWFjdCwgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjaywgdXNlUmVmIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyB1c2VTZXNzaW9uIH0gZnJvbSAnbmV4dC1hdXRoL3JlYWN0J1xuaW1wb3J0IHRvYXN0IGZyb20gJ3JlYWN0LWhvdC10b2FzdCdcblxuaW50ZXJmYWNlIFBlbmRpbmdSYXRpbmcge1xuICB2aWRlb0lkOiBzdHJpbmdcbiAgdGFnSWQ6IHN0cmluZ1xuICByYXRpbmc6IG51bWJlclxuICB0aW1lc3RhbXA6IG51bWJlclxufVxuXG5pbnRlcmZhY2UgUmF0aW5nQ2FjaGVDb250ZXh0VHlwZSB7XG4gIHBlbmRpbmdSYXRpbmdzOiBNYXA8c3RyaW5nLCBQZW5kaW5nUmF0aW5nPlxuICBzZXRDYWNoZWRSYXRpbmc6ICh2aWRlb0lkOiBzdHJpbmcsIHRhZ0lkOiBzdHJpbmcsIHJhdGluZzogbnVtYmVyKSA9PiB2b2lkXG4gIGdldENhY2hlZFJhdGluZzogKHZpZGVvSWQ6IHN0cmluZywgdGFnSWQ6IHN0cmluZykgPT4gbnVtYmVyIHwgbnVsbFxuICBoYXNQZW5kaW5nUmF0aW5nOiAodmlkZW9JZDogc3RyaW5nLCB0YWdJZDogc3RyaW5nKSA9PiBib29sZWFuXG4gIGZsdXNoUGVuZGluZ1JhdGluZ3M6ICgpID0+IFByb21pc2U8dm9pZD5cbiAgc2V0RGVib3VuY2VEZWxheTogKGRlbGF5OiBudW1iZXIpID0+IHZvaWRcbiAgZ2V0RGVib3VuY2VEZWxheTogKCkgPT4gbnVtYmVyXG4gIGdldENhY2hlU3RhdHM6ICgpID0+IHsgcGVuZGluZ0NvdW50OiBudW1iZXI7IG9sZGVzdFRpbWVzdGFtcDogbnVtYmVyIHwgbnVsbCB9XG59XG5cbmNvbnN0IFJhdGluZ0NhY2hlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8UmF0aW5nQ2FjaGVDb250ZXh0VHlwZSB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKVxuXG5jb25zdCBERUZBVUxUX0RFQk9VTkNFX0RFTEFZID0gMzAwMCAvLyAzIHNlY29uZHNcbmNvbnN0IE1BWF9DQUNIRV9BR0UgPSAzMDAwMCAvLyAzMCBzZWNvbmRzIG1heCBhZ2UgYmVmb3JlIGZvcmNlZCBmbHVzaFxuY29uc3QgU1RPUkFHRV9LRVkgPSAncmF0ZW15X3BlbmRpbmdfcmF0aW5ncydcbmNvbnN0IERFQk9VTkNFX0RFTEFZX0tFWSA9ICdyYXRlbXlfZGVib3VuY2VfZGVsYXknXG5cbmV4cG9ydCBmdW5jdGlvbiBSYXRpbmdDYWNoZVByb3ZpZGVyKHsgY2hpbGRyZW4gfTogeyBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlIH0pIHtcbiAgY29uc3QgeyBkYXRhOiBzZXNzaW9uIH0gPSB1c2VTZXNzaW9uKClcbiAgY29uc3QgW3BlbmRpbmdSYXRpbmdzLCBzZXRQZW5kaW5nUmF0aW5nc10gPSB1c2VTdGF0ZTxNYXA8c3RyaW5nLCBQZW5kaW5nUmF0aW5nPj4obmV3IE1hcCgpKVxuICBjb25zdCBbZGVib3VuY2VUaW1lciwgc2V0RGVib3VuY2VUaW1lcl0gPSB1c2VTdGF0ZTxOb2RlSlMuVGltZW91dCB8IG51bGw+KG51bGwpXG4gIGNvbnN0IFtkZWJvdW5jZURlbGF5LCBzZXREZWJvdW5jZURlbGF5U3RhdGVdID0gdXNlU3RhdGU8bnVtYmVyPihERUZBVUxUX0RFQk9VTkNFX0RFTEFZKVxuICBjb25zdCBbaXNJbml0aWFsaXplZCwgc2V0SXNJbml0aWFsaXplZF0gPSB1c2VTdGF0ZShmYWxzZSlcbiAgXG4gIC8vIFVzZSBhIHJlZiB0byBhdm9pZCBzdGFsZSBjbG9zdXJlIGlzc3VlcyB3aXRoIHRoZSB0aW1lclxuICBjb25zdCBmbHVzaFBlbmRpbmdSYXRpbmdzUmVmID0gdXNlUmVmPCgoKSA9PiBQcm9taXNlPHZvaWQ+KSB8IG51bGw+KG51bGwpXG5cbiAgLy8gR2VuZXJhdGUgY2FjaGUga2V5IGZvciBhIHJhdGluZ1xuICBjb25zdCBnZXRDYWNoZUtleSA9ICh2aWRlb0lkOiBzdHJpbmcsIHRhZ0lkOiBzdHJpbmcpID0+IGAke3ZpZGVvSWR9OiR7dGFnSWR9YFxuXG4gIC8vIExvYWQgcGVuZGluZyByYXRpbmdzIGZyb20gbG9jYWxTdG9yYWdlXG4gIGNvbnN0IGxvYWRGcm9tU3RvcmFnZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBuZXcgTWFwKClcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RvcmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oU1RPUkFHRV9LRVkpXG4gICAgICBpZiAoIXN0b3JlZCkgcmV0dXJuIG5ldyBNYXAoKVxuICAgICAgXG4gICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHN0b3JlZCkgYXMgQXJyYXk8W3N0cmluZywgUGVuZGluZ1JhdGluZ10+XG4gICAgICBjb25zdCByYXRpbmdzTWFwID0gbmV3IE1hcChwYXJzZWQpXG4gICAgICBcbiAgICAgIC8vIEZpbHRlciBvdXQgb2xkIHJhdGluZ3NcbiAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KClcbiAgICAgIGNvbnN0IGZpbHRlcmVkTWFwID0gbmV3IE1hcCgpXG4gICAgICByYXRpbmdzTWFwLmZvckVhY2goKHJhdGluZywga2V5KSA9PiB7XG4gICAgICAgIGlmIChub3cgLSByYXRpbmcudGltZXN0YW1wIDw9IE1BWF9DQUNIRV9BR0UpIHtcbiAgICAgICAgICBmaWx0ZXJlZE1hcC5zZXQoa2V5LCByYXRpbmcpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBcbiAgICAgIHJldHVybiBmaWx0ZXJlZE1hcFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBsb2FkIHBlbmRpbmcgcmF0aW5ncyBmcm9tIHN0b3JhZ2U6JywgZXJyb3IpXG4gICAgICByZXR1cm4gbmV3IE1hcCgpXG4gICAgfVxuICB9LCBbXSlcblxuICAvLyBTYXZlIHBlbmRpbmcgcmF0aW5ncyB0byBsb2NhbFN0b3JhZ2VcbiAgY29uc3Qgc2F2ZVRvU3RvcmFnZSA9IHVzZUNhbGxiYWNrKChyYXRpbmdzOiBNYXA8c3RyaW5nLCBQZW5kaW5nUmF0aW5nPikgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuXG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJhdGluZ3NBcnJheSA9IEFycmF5LmZyb20ocmF0aW5ncy5lbnRyaWVzKCkpXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShTVE9SQUdFX0tFWSwgSlNPTi5zdHJpbmdpZnkocmF0aW5nc0FycmF5KSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gc2F2ZSBwZW5kaW5nIHJhdGluZ3MgdG8gc3RvcmFnZTonLCBlcnJvcilcbiAgICB9XG4gIH0sIFtdKVxuXG4gIC8vIENsZWFyIHN0b3JhZ2VcbiAgY29uc3QgY2xlYXJTdG9yYWdlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuXG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKFNUT1JBR0VfS0VZKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBjbGVhciBwZW5kaW5nIHJhdGluZ3MgZnJvbSBzdG9yYWdlOicsIGVycm9yKVxuICAgIH1cbiAgfSwgW10pXG5cbiAgLy8gU2V0IGEgY2FjaGVkIHJhdGluZyAod2lsbCBiZSBzYXZlZCB0byBEQiBhZnRlciBkZWJvdW5jZSBkZWxheSlcbiAgY29uc3Qgc2V0Q2FjaGVkUmF0aW5nID0gdXNlQ2FsbGJhY2soKHZpZGVvSWQ6IHN0cmluZywgdGFnSWQ6IHN0cmluZywgcmF0aW5nOiBudW1iZXIpID0+IHtcbiAgICBpZiAoIXNlc3Npb24pIHJldHVyblxuXG4gICAgY29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMV0uc3BsaXQoJy4nKVswXVxuICAgIGNvbnNvbGUubG9nKGDirZAgWyR7dGltZXN0YW1wfV0gU0VUVElORyBDQUNIRUQgUkFUSU5HOiAke3ZpZGVvSWR9OiR7dGFnSWR9ID0gJHtyYXRpbmd9YClcbiAgICBjb25zdCBrZXkgPSBnZXRDYWNoZUtleSh2aWRlb0lkLCB0YWdJZClcbiAgICBjb25zdCBwZW5kaW5nUmF0aW5nOiBQZW5kaW5nUmF0aW5nID0ge1xuICAgICAgdmlkZW9JZCxcbiAgICAgIHRhZ0lkLCBcbiAgICAgIHJhdGluZyxcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgIH1cblxuICAgIHNldFBlbmRpbmdSYXRpbmdzKHByZXYgPT4ge1xuICAgICAgY29uc3QgbmV3TWFwID0gbmV3IE1hcChwcmV2KVxuICAgICAgbmV3TWFwLnNldChrZXksIHBlbmRpbmdSYXRpbmcpXG4gICAgICBcbiAgICAgIC8vIFNhdmUgdG8gbG9jYWxTdG9yYWdlIGltbWVkaWF0ZWx5XG4gICAgICBzYXZlVG9TdG9yYWdlKG5ld01hcClcbiAgICAgIFxuICAgICAgcmV0dXJuIG5ld01hcFxuICAgIH0pXG5cbiAgICAvLyBSZXNldCBkZWJvdW5jZSB0aW1lclxuICAgIGlmIChkZWJvdW5jZVRpbWVyKSB7XG4gICAgICBjb25zb2xlLmxvZyhg4o+wIENsZWFyaW5nIGV4aXN0aW5nIHRpbWVyIGZvciBuZXcgcmF0aW5nOiAke3ZpZGVvSWR9OiR7dGFnSWR9YClcbiAgICAgIGNsZWFyVGltZW91dChkZWJvdW5jZVRpbWVyKVxuICAgIH1cblxuICAgIGNvbnN0IG5ld1RpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhg4o+wIFRpbWVyIGV4cGlyZWQsIGZsdXNoaW5nIGFsbCBwZW5kaW5nIHJhdGluZ3NgKVxuICAgICAgLy8gVXNlIHJlZiB0byBhdm9pZCBzdGFsZSBjbG9zdXJlXG4gICAgICBpZiAoZmx1c2hQZW5kaW5nUmF0aW5nc1JlZi5jdXJyZW50KSB7XG4gICAgICAgIGZsdXNoUGVuZGluZ1JhdGluZ3NSZWYuY3VycmVudCgpXG4gICAgICB9XG4gICAgfSwgZGVib3VuY2VEZWxheSlcbiAgICBcbiAgICBjb25zb2xlLmxvZyhg4o+wIFNldCBuZXcgdGltZXIgZm9yICR7ZGVib3VuY2VEZWxheX1tc2ApXG4gICAgc2V0RGVib3VuY2VUaW1lcihuZXdUaW1lcilcbiAgfSwgW3Nlc3Npb24sIGRlYm91bmNlVGltZXIsIHNhdmVUb1N0b3JhZ2UsIGRlYm91bmNlRGVsYXldKVxuXG4gIC8vIEdldCBjYWNoZWQgcmF0aW5nIHZhbHVlXG4gIGNvbnN0IGdldENhY2hlZFJhdGluZyA9IHVzZUNhbGxiYWNrKCh2aWRlb0lkOiBzdHJpbmcsIHRhZ0lkOiBzdHJpbmcpOiBudW1iZXIgfCBudWxsID0+IHtcbiAgICBjb25zdCBrZXkgPSBnZXRDYWNoZUtleSh2aWRlb0lkLCB0YWdJZClcbiAgICBjb25zdCBwZW5kaW5nID0gcGVuZGluZ1JhdGluZ3MuZ2V0KGtleSlcbiAgICBcbiAgICBpZiAocGVuZGluZykge1xuICAgICAgLy8gVmFsaWRhdGUgdGhhdCB0aGUgY2FjaGVkIHJhdGluZyBtYXRjaGVzIHRoZSByZXF1ZXN0ZWQgdmlkZW8vdGFnXG4gICAgICBpZiAocGVuZGluZy52aWRlb0lkICE9PSB2aWRlb0lkIHx8IHBlbmRpbmcudGFnSWQgIT09IHRhZ0lkKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYPCfmqggQ0FDSEVEIFJBVElORyBNSVNNQVRDSDogcmVxdWVzdGVkICR7dmlkZW9JZH06JHt0YWdJZH0sIGdvdCAke3BlbmRpbmcudmlkZW9JZH06JHtwZW5kaW5nLnRhZ0lkfSwgcmVtb3ZpbmcgY29ycnVwdCBjYWNoZSBlbnRyeWApXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgY29ycnVwdCBjYWNoZSBlbnRyeVxuICAgICAgICBjb25zdCBjb3JydXB0ZWRLZXkgPSBrZXlcbiAgICAgICAgc2V0UGVuZGluZ1JhdGluZ3MocHJldiA9PiB7XG4gICAgICAgICAgY29uc3QgY2xlYW5lZCA9IG5ldyBNYXAocHJldilcbiAgICAgICAgICBjbGVhbmVkLmRlbGV0ZShjb3JydXB0ZWRLZXkpXG4gICAgICAgICAgcmV0dXJuIGNsZWFuZWRcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUubG9nKGDwn5OKIFske25ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzFdLnNwbGl0KCcuJylbMF19XSBDYWNoZSBoaXQ6ICR7dmlkZW9JZH06JHt0YWdJZH0gPSAke3BlbmRpbmcucmF0aW5nfWApXG4gICAgICByZXR1cm4gcGVuZGluZy5yYXRpbmdcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG51bGxcbiAgfSwgW3BlbmRpbmdSYXRpbmdzLCBzZXRQZW5kaW5nUmF0aW5nc10pXG5cbiAgLy8gQ2hlY2sgaWYgdGhlcmUncyBhIHBlbmRpbmcgcmF0aW5nXG4gIGNvbnN0IGhhc1BlbmRpbmdSYXRpbmcgPSB1c2VDYWxsYmFjaygodmlkZW9JZDogc3RyaW5nLCB0YWdJZDogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gICAgY29uc3Qga2V5ID0gZ2V0Q2FjaGVLZXkodmlkZW9JZCwgdGFnSWQpXG4gICAgY29uc3QgcmF0aW5nID0gcGVuZGluZ1JhdGluZ3MuZ2V0KGtleSlcbiAgICBpZiAoIXJhdGluZykgcmV0dXJuIGZhbHNlXG4gICAgXG4gICAgLy8gVmFsaWRhdGUgdGhhdCB0aGUgY2FjaGVkIHJhdGluZyBtYXRjaGVzIHRoZSByZXF1ZXN0ZWQgdmlkZW8vdGFnXG4gICAgaWYgKHJhdGluZy52aWRlb0lkICE9PSB2aWRlb0lkIHx8IHJhdGluZy50YWdJZCAhPT0gdGFnSWQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYPCfmqggUEVORElORyBSQVRJTkcgTUlTTUFUQ0g6IHJlcXVlc3RlZCAke3ZpZGVvSWR9OiR7dGFnSWR9LCBnb3QgJHtyYXRpbmcudmlkZW9JZH06JHtyYXRpbmcudGFnSWR9YClcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGFuIGV4cGlyZWQgXCJzYXZlZFwiIHJhdGluZ1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KClcbiAgICBpZiAocmF0aW5nLnRpbWVzdGFtcCA+IG5vdyAmJiByYXRpbmcudGltZXN0YW1wIC0gbm93IDwgNjAwMCkge1xuICAgICAgLy8gVGhpcyBpcyBhIHNhdmVkIHJhdGluZyB0aGF0J3MgdGVtcG9yYXJpbHkga2VwdCB0byBwcmV2ZW50IHZpc3VhbCByZXZlcnRcbiAgICAgIC8vIERvbid0IHNob3cgaXQgYXMgcGVuZGluZyBzaW5jZSBpdCdzIGFscmVhZHkgc2F2ZWRcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gdHJ1ZVxuICB9LCBbcGVuZGluZ1JhdGluZ3NdKVxuXG4gIC8vIEZsdXNoIGFsbCBwZW5kaW5nIHJhdGluZ3MgdG8gZGF0YWJhc2UgdXNpbmcgYnVsayBBUElcbiAgY29uc3QgZmx1c2hQZW5kaW5nUmF0aW5ncyA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICBpZiAocGVuZGluZ1JhdGluZ3Muc2l6ZSA9PT0gMCB8fCAhc2Vzc2lvbikgcmV0dXJuXG5cbiAgICAvLyBPbmx5IGZsdXNoIGFjdHVhbCBwZW5kaW5nIHJhdGluZ3MsIG5vdCB0ZW1wb3JhcmlseSBzYXZlZCBvbmVzXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKVxuICAgIGNvbnN0IGFjdHVhbFBlbmRpbmdSYXRpbmdzID0gQXJyYXkuZnJvbShwZW5kaW5nUmF0aW5ncy52YWx1ZXMoKSkuZmlsdGVyKHJhdGluZyA9PiBcbiAgICAgIHJhdGluZy50aW1lc3RhbXAgPD0gbm93IC8vIE5vcm1hbCBwZW5kaW5nIHJhdGluZ3MgaGF2ZSBwYXN0IHRpbWVzdGFtcHNcbiAgICApXG4gICAgXG4gICAgY29uc29sZS5sb2coYPCflI0gRkxVU0ggQU5BTFlTSVM6IFRvdGFsIGNhY2hlIGVudHJpZXM9JHtwZW5kaW5nUmF0aW5ncy5zaXplfSwgQWN0dWFsIHBlbmRpbmc9JHthY3R1YWxQZW5kaW5nUmF0aW5ncy5sZW5ndGh9YClcbiAgICBhY3R1YWxQZW5kaW5nUmF0aW5ncy5mb3JFYWNoKHJhdGluZyA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhgICAg4oaSICR7cmF0aW5nLnZpZGVvSWR9OiR7cmF0aW5nLnRhZ0lkfSA9ICR7cmF0aW5nLnJhdGluZ30gKGFnZTogJHsobm93IC0gcmF0aW5nLnRpbWVzdGFtcCkvMTAwMH1zKWApXG4gICAgfSlcbiAgICBcbiAgICBpZiAoYWN0dWFsUGVuZGluZ1JhdGluZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+agCBObyBhY3R1YWwgcGVuZGluZyByYXRpbmdzIHRvIGZsdXNoIChvbmx5IHNhdmVkIG9uZXMpJylcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCfwn5qAIEZMVVNISU5HIFJBVElOR1M6JywgYWN0dWFsUGVuZGluZ1JhdGluZ3MubGVuZ3RoLCAnYWN0dWFsIHBlbmRpbmcgcmF0aW5ncyBvdXQgb2YnLCBwZW5kaW5nUmF0aW5ncy5zaXplLCAndG90YWwnKVxuICAgIGNvbnN0IHJhdGluZ3NUb1NhdmUgPSBhY3R1YWxQZW5kaW5nUmF0aW5nc1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBVc2UgYnVsayBmbHVzaCBBUEkgZm9yIGJldHRlciBwZXJmb3JtYW5jZVxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9yYXRpbmdzL2ZsdXNoJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZScsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJhdGluZ3NUb1NhdmUubWFwKHJhdGluZyA9PiAoe1xuICAgICAgICAgIHZpZGVvSWQ6IHJhdGluZy52aWRlb0lkLFxuICAgICAgICAgIHRhZ0lkOiByYXRpbmcudGFnSWQsXG4gICAgICAgICAgcmF0aW5nOiByYXRpbmcucmF0aW5nLFxuICAgICAgICAgIHRpbWVzdGFtcDogcmF0aW5nLnRpbWVzdGFtcFxuICAgICAgICB9KSkpLFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfTogRmFpbGVkIHRvIGZsdXNoIHJhdGluZ3NgKVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICAgIFxuICAgICAgLy8gQWRkIGRldGFpbGVkIEFQSSByZXNwb25zZSBsb2dnaW5nXG4gICAgICBjb25zb2xlLmxvZygn8J+ToSBGVUxMIEFQSSBSRVNQT05TRTonLCBKU09OLnN0cmluZ2lmeShyZXN1bHQsIG51bGwsIDIpKVxuICAgICAgY29uc29sZS5sb2coJ/Cfk4ogQVBJIFJlc3BvbnNlIFN1bW1hcnk6Jywge1xuICAgICAgICBzdWNjZXNzOiByZXN1bHQuc3VjY2VzcyxcbiAgICAgICAgcHJvY2Vzc2VkOiByZXN1bHQuZGF0YT8ucHJvY2Vzc2VkLFxuICAgICAgICBzdWNjZXNzZnVsOiByZXN1bHQuZGF0YT8uc3VjY2Vzc2Z1bCxcbiAgICAgICAgZmFpbGVkOiByZXN1bHQuZGF0YT8uZmFpbGVkLFxuICAgICAgICBoYXNFcnJvcnM6ICEhKHJlc3VsdC5kYXRhPy5lcnJvcnMgJiYgcmVzdWx0LmRhdGEuZXJyb3JzLmxlbmd0aCA+IDApLFxuICAgICAgICBlcnJvckNvdW50OiByZXN1bHQuZGF0YT8uZXJyb3JzPy5sZW5ndGggfHwgMCxcbiAgICAgICAgbWVzc2FnZTogcmVzdWx0Lm1lc3NhZ2UsXG4gICAgICAgIGVycm9yOiByZXN1bHQuZXJyb3JcbiAgICAgIH0pXG4gICAgICBcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEFQSSBFUlJPUiBERVRBSUxTOicsIHJlc3VsdClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3VsdC5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gc2F2ZSByYXRpbmdzJylcbiAgICAgIH1cblxuICAgICAgLy8gTm90aWZ5IGNvbXBvbmVudHMgdGhhdCByYXRpbmdzIHdlcmUgc2F2ZWQgYmVmb3JlIGNsZWFyaW5nIHRoZSBjYWNoZVxuICAgICAgLy8gTm90ZTogUmVtb3ZlZCBhdXRvbWF0aWMgY2FsbGJhY2sgZXhlY3V0aW9uIHRvIHByZXZlbnQgdW53YW50ZWQgcGFnZSByZWZyZXNoZXNcbiAgICAgIC8vIENvbXBvbmVudHMgY2FuIG1hbnVhbGx5IGNoZWNrIGZvciByYXRpbmcgdXBkYXRlcyBvciB1c2Ugc2VydmVyLXNpZGUgY2FjaGluZyBpbnN0ZWFkXG5cbiAgICAgIGNvbnN0IHsgc3VjY2Vzc2Z1bCwgZmFpbGVkLCByZXN1bHRzLCBlcnJvcnMgfSA9IHJlc3VsdC5kYXRhXG4gICAgICBcbiAgICAgIC8vIE9ubHkgY2xlYXIgc3VjY2Vzc2Z1bGx5IHNhdmVkIHJhdGluZ3MgZnJvbSBjYWNoZVxuICAgICAgY29uc3Qgc3VjY2Vzc2Z1bEtleXMgPSBuZXcgU2V0PHN0cmluZz4oKVxuICAgICAgY29uc3QgZmFpbGVkS2V5cyA9IG5ldyBTZXQ8c3RyaW5nPigpXG4gICAgICBcbiAgICAgIC8vIFByb2Nlc3Mgc3VjY2Vzc2Z1bCByZXN1bHRzXG4gICAgICBpZiAocmVzdWx0cyAmJiBBcnJheS5pc0FycmF5KHJlc3VsdHMpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfinIUgU3VjY2Vzc2Z1bGx5IHNhdmVkIHJhdGluZ3M6JywgcmVzdWx0cy5sZW5ndGgpXG4gICAgICAgIHJlc3VsdHMuZm9yRWFjaCgocmVzdWx0OiBhbnkpID0+IHtcbiAgICAgICAgICBjb25zdCBrZXkgPSBnZXRDYWNoZUtleShyZXN1bHQudmlkZW9JZCwgcmVzdWx0LnRhZ0lkKVxuICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgU3VjY2VzczogJHtyZXN1bHQudmlkZW9JZH06JHtyZXN1bHQudGFnSWR9IChrZXk6ICR7a2V5fSlgKVxuICAgICAgICAgIHN1Y2Nlc3NmdWxLZXlzLmFkZChrZXkpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFByb2Nlc3MgZmFpbGVkIHJlc3VsdHMgIFxuICAgICAgaWYgKGVycm9ycyAmJiBBcnJheS5pc0FycmF5KGVycm9ycykpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KdjCBGYWlsZWQgdG8gc2F2ZSByYXRpbmdzOicsIGVycm9ycy5sZW5ndGgpXG4gICAgICAgIGVycm9ycy5mb3JFYWNoKChlcnJvcjogYW55KSA9PiB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gZ2V0Q2FjaGVLZXkoZXJyb3IudmlkZW9JZCwgZXJyb3IudGFnSWQpXG4gICAgICAgICAgY29uc29sZS5sb2coYOKdjCBGYWlsZWQ6ICR7ZXJyb3IudmlkZW9JZH06JHtlcnJvci50YWdJZH0gLSAke2Vycm9yLmVycm9yfWApXG4gICAgICAgICAgZmFpbGVkS2V5cy5hZGQoa2V5KVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBVcGRhdGUgcGVuZGluZyByYXRpbmdzIC0ga2VlcCBzdWNjZXNzZnVsIG9uZXMgYXMgXCJzYXZlZFwiIGZvciBhIHNob3J0IHRpbWVcbiAgICAgIC8vIHRvIHByZXZlbnQgdmlzdWFsIHJldmVyc2lvbiB1bnRpbCBjb21wb25lbnRzIGdldCBmcmVzaCBkYXRhXG4gICAgICBjb25zdCBuZXdQZW5kaW5nUmF0aW5ncyA9IG5ldyBNYXA8c3RyaW5nLCBQZW5kaW5nUmF0aW5nPigpXG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCfwn6e5IENsZWFyaW5nIGNhY2hlOiBiZWZvcmUgPScsIHBlbmRpbmdSYXRpbmdzLnNpemUsICdzdWNjZXNzZnVsID0nLCBzdWNjZXNzZnVsS2V5cy5zaXplLCAnZmFpbGVkID0nLCBmYWlsZWRLZXlzLnNpemUpXG4gICAgICBcbiAgICAgIHBlbmRpbmdSYXRpbmdzLmZvckVhY2goKHJhdGluZywga2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkS2V5ID0gZ2V0Q2FjaGVLZXkocmF0aW5nLnZpZGVvSWQsIHJhdGluZy50YWdJZClcbiAgICAgICAgaWYgKGtleSAhPT0gZXhwZWN0ZWRLZXkpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGDwn5qoIENBQ0hFIEtFWSBNSVNNQVRDSDogc3RvcmVkIGtleT0ke2tleX0sIGV4cGVjdGVkPSR7ZXhwZWN0ZWRLZXl9YClcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBzcGVjaWZpYyByYXRpbmcgd2FzIGluIHRoZSBiYXRjaCB0aGF0IHdhcyBmbHVzaGVkXG4gICAgICAgIGNvbnN0IHdhc0luRmx1c2hCYXRjaCA9IHJhdGluZ3NUb1NhdmUuc29tZShmbHVzaGVkUmF0aW5nID0+IFxuICAgICAgICAgIGZsdXNoZWRSYXRpbmcudmlkZW9JZCA9PT0gcmF0aW5nLnZpZGVvSWQgJiYgZmx1c2hlZFJhdGluZy50YWdJZCA9PT0gcmF0aW5nLnRhZ0lkXG4gICAgICAgIClcbiAgICAgICAgXG4gICAgICAgIGlmIChmYWlsZWRLZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgLy8gS2VlcCByYXRpbmdzIHRoYXQgZmFpbGVkIHRvIHNhdmUgLSB0aGV5IG5lZWQgdG8gYmUgcmV0cmllZFxuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5SEIEtlZXBpbmcgZmFpbGVkIHJhdGluZyBpbiBjYWNoZTogJHtyYXRpbmcudmlkZW9JZH06JHtyYXRpbmcudGFnSWR9YClcbiAgICAgICAgICBuZXdQZW5kaW5nUmF0aW5ncy5zZXQoa2V5LCByYXRpbmcpXG4gICAgICAgIH0gZWxzZSBpZiAoc3VjY2Vzc2Z1bEtleXMuaGFzKGtleSkgJiYgd2FzSW5GbHVzaEJhdGNoKSB7XG4gICAgICAgICAgLy8gT25seSBtYXJrIGFzIHRlbXBvcmFyaWx5IHNhdmVkIGlmIGl0IHdhcyBhY3R1YWxseSBpbiB0aGUgZmx1c2ggYmF0Y2hcbiAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIEtlZXBpbmcgc3VjY2Vzc2Z1bCByYXRpbmcgdGVtcG9yYXJpbHk6ICR7cmF0aW5nLnZpZGVvSWR9OiR7cmF0aW5nLnRhZ0lkfWApXG4gICAgICAgICAgbmV3UGVuZGluZ1JhdGluZ3Muc2V0KGtleSwge1xuICAgICAgICAgICAgLi4ucmF0aW5nLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpICsgNTAwMCAvLyBNYXJrIGFzIHNhdmVkLCB3aWxsIGF1dG8tZXhwaXJlIGluIDUgc2Vjb25kcyAobG9uZ2VyIHRvIGhhbmRsZSBjb21wb25lbnQgcmUtcmVuZGVycylcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2UgaWYgKCF3YXNJbkZsdXNoQmF0Y2gpIHtcbiAgICAgICAgICAvLyBUaGlzIHJhdGluZyB3YXNuJ3QgaW4gdGhlIGZsdXNoIGJhdGNoLCBzbyBrZWVwIGl0IGFzLWlzXG4gICAgICAgICAgY29uc29sZS5sb2coYPCflIQgS2VlcGluZyB1bmZsdXNoZWQgcmF0aW5nOiAke3JhdGluZy52aWRlb0lkfToke3JhdGluZy50YWdJZH1gKVxuICAgICAgICAgIG5ld1BlbmRpbmdSYXRpbmdzLnNldChrZXksIHJhdGluZylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhg4pqg77iPIFJhdGluZyBub3QgaW4gc3VjY2VzcyBvciBmYWlsIGxpc3Q6ICR7cmF0aW5nLnZpZGVvSWR9OiR7cmF0aW5nLnRhZ0lkfSAoa2V5OiAke2tleX0pYClcbiAgICAgICAgICAvLyBLZWVwIHVua25vd24gcmF0aW5ncyB0byBiZSBzYWZlXG4gICAgICAgICAgbmV3UGVuZGluZ1JhdGluZ3Muc2V0KGtleSwgcmF0aW5nKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgXG4gICAgICBzZXRQZW5kaW5nUmF0aW5ncyhuZXdQZW5kaW5nUmF0aW5ncylcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIGxvY2FsU3RvcmFnZSBzdG9yYWdlXG4gICAgICBpZiAobmV3UGVuZGluZ1JhdGluZ3Muc2l6ZSA9PT0gMCkge1xuICAgICAgICBjbGVhclN0b3JhZ2UoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2F2ZVRvU3RvcmFnZShuZXdQZW5kaW5nUmF0aW5ncylcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2xlYXIgZGVib3VuY2UgdGltZXIgb25seSBpZiBhbGwgcmF0aW5ncyB3ZXJlIHByb2Nlc3NlZFxuICAgICAgaWYgKGZhaWxlZCA9PT0gMCAmJiBkZWJvdW5jZVRpbWVyKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChkZWJvdW5jZVRpbWVyKVxuICAgICAgICBzZXREZWJvdW5jZVRpbWVyKG51bGwpXG4gICAgICB9XG5cbiAgICAgIC8vIExvZyBzdWNjZXNzIHdpdGggZGV0YWlsZWQgaW5mb1xuICAgICAgY29uc29sZS5sb2coYEJ1bGsgcmF0aW5nIGZsdXNoIGNvbXBsZXRlZDogJHtzdWNjZXNzZnVsfSBzdWNjZXNzZnVsLCAke2ZhaWxlZH0gZmFpbGVkIG91dCBvZiAke3JhdGluZ3NUb1NhdmUubGVuZ3RofSB0b3RhbGApXG4gICAgICBcbiAgICAgIGlmIChmYWlsZWQgPiAwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignU29tZSByYXRpbmdzIGZhaWxlZCB0byBzYXZlOicsIGVycm9ycylcbiAgICAgICAgdG9hc3QuZXJyb3IoYCR7ZmFpbGVkfSByYXRpbmdzIGNvdWxkIG5vdCBiZSBzYXZlZC4gVGhleSB3aWxsIGJlIHJldHJpZWQgYXV0b21hdGljYWxseS5gKVxuICAgICAgfVxuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZsdXNoaW5nIHBlbmRpbmcgcmF0aW5nczonLCBlcnJvcilcbiAgICAgIHRvYXN0LmVycm9yKCdTb21lIHJhdGluZ3MgY291bGQgbm90IGJlIHNhdmVkLiBQbGVhc2UgdHJ5IGFnYWluLicpXG4gICAgICBcbiAgICAgIC8vIERvbid0IGNsZWFyIGNhY2hlIG9uIGVycm9yIC0gYWxsb3cgcmV0cnlcbiAgICB9XG4gIH0sIFtwZW5kaW5nUmF0aW5ncywgc2Vzc2lvbiwgZGVib3VuY2VUaW1lciwgY2xlYXJTdG9yYWdlXSlcblxuICAvLyBBc3NpZ24gdGhlIGZ1bmN0aW9uIHRvIHRoZSByZWYgdG8gYXZvaWQgc3RhbGUgY2xvc3VyZSBpc3N1ZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBmbHVzaFBlbmRpbmdSYXRpbmdzUmVmLmN1cnJlbnQgPSBmbHVzaFBlbmRpbmdSYXRpbmdzXG4gIH0sIFtmbHVzaFBlbmRpbmdSYXRpbmdzXSlcblxuICAvLyBJbml0aWFsaXplIGZyb20gbG9jYWxTdG9yYWdlIG9uIG1vdW50XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFpc0luaXRpYWxpemVkICYmIHNlc3Npb24pIHtcbiAgICAgIGNvbnN0IHN0b3JlZFJhdGluZ3MgPSBsb2FkRnJvbVN0b3JhZ2UoKVxuICAgICAgaWYgKHN0b3JlZFJhdGluZ3Muc2l6ZSA+IDApIHtcbiAgICAgICAgc2V0UGVuZGluZ1JhdGluZ3Moc3RvcmVkUmF0aW5ncylcbiAgICAgICAgXG4gICAgICAgIC8vIERpc2FibGUgaW1tZWRpYXRlIGZsdXNoIHRvIHByZXZlbnQgdW53YW50ZWQgQVBJIGNhbGxzIG9uIGxvYWRcbiAgICAgICAgLy8gc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgIC8vICAgdHJ5IHtcbiAgICAgICAgLy8gICAgIGF3YWl0IGZsdXNoUGVuZGluZ1JhdGluZ3MoKVxuICAgICAgICAvLyAgICAgY29uc29sZS5sb2coJ1N1Y2Nlc3NmdWxseSBmbHVzaGVkIHBlbmRpbmcgcmF0aW5ncyBmcm9tIGxvY2FsU3RvcmFnZScpXG4gICAgICAgIC8vICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBmbHVzaCByYXRpbmdzIG9uIGxvYWQ6JywgZXJyb3IpXG4gICAgICAgIC8vICAgfVxuICAgICAgICAvLyB9LCAxMDApIC8vIFZlcnkgc2hvcnQgZGVsYXkganVzdCB0byBlbnN1cmUgY29tcG9uZW50IGlzIG1vdW50ZWRcbiAgICAgIH1cbiAgICAgIHNldElzSW5pdGlhbGl6ZWQodHJ1ZSlcbiAgICB9XG4gIH0sIFtzZXNzaW9uLCBpc0luaXRpYWxpemVkLCBsb2FkRnJvbVN0b3JhZ2UsIGZsdXNoUGVuZGluZ1JhdGluZ3NdKVxuXG4gIC8vIENsZWFuIHVwIGV4cGlyZWQgXCJzYXZlZFwiIHJhdGluZ3MgcGVyaW9kaWNhbGx5XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFpc0luaXRpYWxpemVkKSByZXR1cm5cbiAgICBcbiAgICBjb25zdCBjbGVhbnVwSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpXG4gICAgICBsZXQgaGFzRXhwaXJlZFJhdGluZ3MgPSBmYWxzZVxuICAgICAgXG4gICAgICAvLyBDaGVjayBmb3IgZXhwaXJlZCBcInNhdmVkXCIgcmF0aW5ncyAodGhvc2Ugd2l0aCBmdXR1cmUgdGltZXN0YW1wcyB0aGF0IGhhdmUgcGFzc2VkKVxuICAgICAgZm9yIChjb25zdCByYXRpbmcgb2YgQXJyYXkuZnJvbShwZW5kaW5nUmF0aW5ncy52YWx1ZXMoKSkpIHtcbiAgICAgICAgaWYgKHJhdGluZy50aW1lc3RhbXAgPiBub3cgLSA4MDAwICYmIHJhdGluZy50aW1lc3RhbXAgPD0gbm93ICsgNjAwMCkge1xuICAgICAgICAgIC8vIFRoaXMgbWlnaHQgYmUgYSBzYXZlZCByYXRpbmcgdGhhdCBzaG91bGQgYmUgY2xlYW5lZCB1cFxuICAgICAgICAgIGhhc0V4cGlyZWRSYXRpbmdzID0gdHJ1ZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKGhhc0V4cGlyZWRSYXRpbmdzKSB7XG4gICAgICAgIHNldFBlbmRpbmdSYXRpbmdzKHByZXYgPT4ge1xuICAgICAgICAgIGNvbnN0IGNsZWFuZWQgPSBuZXcgTWFwPHN0cmluZywgUGVuZGluZ1JhdGluZz4oKVxuICAgICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKVxuICAgICAgICAgIFxuICAgICAgICAgIHByZXYuZm9yRWFjaCgocmF0aW5nLCBrZXkpID0+IHtcbiAgICAgICAgICAgIC8vIEtlZXAgcmF0aW5ncyB0aGF0IGFyZSBlaXRoZXI6XG4gICAgICAgICAgICAvLyAxLiBOb3JtYWwgcGVuZGluZyByYXRpbmdzICh0aW1lc3RhbXAgaW4gdGhlIHBhc3QpXG4gICAgICAgICAgICAvLyAyLiBTYXZlZCByYXRpbmdzIHRoYXQgaGF2ZW4ndCBleHBpcmVkIHlldCAodGltZXN0YW1wID4gbm93ICsgYnVmZmVyKVxuICAgICAgICAgICAgaWYgKHJhdGluZy50aW1lc3RhbXAgPD0gY3VycmVudFRpbWUgfHwgcmF0aW5nLnRpbWVzdGFtcCA+IGN1cnJlbnRUaW1lICsgNjAwMCkge1xuICAgICAgICAgICAgICBjbGVhbmVkLnNldChrZXksIHJhdGluZylcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn6e5IENsZWFuaW5nIHVwIGV4cGlyZWQgc2F2ZWQgcmF0aW5nOiAke3JhdGluZy52aWRlb0lkfToke3JhdGluZy50YWdJZH1gKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVXBkYXRlIGxvY2FsU3RvcmFnZSBpZiBhbnl0aGluZyBjaGFuZ2VkXG4gICAgICAgICAgaWYgKGNsZWFuZWQuc2l6ZSAhPT0gcHJldi5zaXplKSB7XG4gICAgICAgICAgICBpZiAoY2xlYW5lZC5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgIGNsZWFyU3RvcmFnZSgpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzYXZlVG9TdG9yYWdlKGNsZWFuZWQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIHJldHVybiBjbGVhbmVkLnNpemUgIT09IHByZXYuc2l6ZSA/IGNsZWFuZWQgOiBwcmV2XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSwgMTAwMCkgLy8gQ2hlY2sgZXZlcnkgc2Vjb25kIGZvciBjbGVhbnVwXG4gICAgXG4gICAgcmV0dXJuICgpID0+IGNsZWFySW50ZXJ2YWwoY2xlYW51cEludGVydmFsKVxuICB9LCBbcGVuZGluZ1JhdGluZ3MsIGlzSW5pdGlhbGl6ZWQsIGNsZWFyU3RvcmFnZSwgc2F2ZVRvU3RvcmFnZV0pXG5cbiAgLy8gRmx1c2ggb24gcGFnZSB1bmxvYWQvYmVmb3JldW5sb2FkXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFpc0luaXRpYWxpemVkKSByZXR1cm5cbiAgICBcbiAgICBjb25zdCBoYW5kbGVCZWZvcmVVbmxvYWQgPSAoKSA9PiB7XG4gICAgICBpZiAocGVuZGluZ1JhdGluZ3Muc2l6ZSA+IDApIHtcbiAgICAgICAgLy8gVXNlIHNlbmRCZWFjb24gZm9yIHJlbGlhYmxlIGRhdGEgdHJhbnNtaXNzaW9uIGR1cmluZyBwYWdlIHVubG9hZFxuICAgICAgICBjb25zdCByYXRpbmdzRGF0YSA9IEFycmF5LmZyb20ocGVuZGluZ1JhdGluZ3MudmFsdWVzKCkpXG4gICAgICAgIG5hdmlnYXRvci5zZW5kQmVhY29uKCcvYXBpL3JhdGluZ3MvZmx1c2gnLCBKU09OLnN0cmluZ2lmeShyYXRpbmdzRGF0YSkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSA9ICgpID0+IHtcbiAgICAgIGlmIChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICdoaWRkZW4nICYmIHBlbmRpbmdSYXRpbmdzLnNpemUgPiAwKSB7XG4gICAgICAgIGZsdXNoUGVuZGluZ1JhdGluZ3MoKVxuICAgICAgfVxuICAgIH1cblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCBoYW5kbGVCZWZvcmVVbmxvYWQpXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIGhhbmRsZVZpc2liaWxpdHlDaGFuZ2UpXG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGhhbmRsZUJlZm9yZVVubG9hZClcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKVxuICAgIH1cbiAgfSwgW3BlbmRpbmdSYXRpbmdzLCBmbHVzaFBlbmRpbmdSYXRpbmdzLCBpc0luaXRpYWxpemVkXSlcblxuICAvLyBDbGVhbnVwIHRpbWVyIG9uIHVubW91bnRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKGRlYm91bmNlVGltZXIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGRlYm91bmNlVGltZXIpXG4gICAgICB9XG4gICAgfVxuICB9LCBbZGVib3VuY2VUaW1lcl0pXG5cbiAgLy8gUmVtb3ZlZCByYXRpbmcgc2F2ZWQgY2FsbGJhY2sgZnVuY3Rpb25zIHRvIHByZXZlbnQgdW53YW50ZWQgcGFnZSByZWZyZXNoZXNcblxuICAvLyBTZXQgY3VzdG9tIGRlYm91bmNlIGRlbGF5XG4gIGNvbnN0IHNldERlYm91bmNlRGVsYXkgPSB1c2VDYWxsYmFjaygoZGVsYXk6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IHZhbGlkYXRlZERlbGF5ID0gTWF0aC5tYXgoMTAwMCwgTWF0aC5taW4oMzAwMDAsIGRlbGF5KSkgLy8gQmV0d2VlbiAxLTMwIHNlY29uZHNcbiAgICBzZXREZWJvdW5jZURlbGF5U3RhdGUodmFsaWRhdGVkRGVsYXkpXG4gICAgXG4gICAgLy8gU2F2ZSB0byBsb2NhbFN0b3JhZ2VcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKERFQk9VTkNFX0RFTEFZX0tFWSwgdmFsaWRhdGVkRGVsYXkudG9TdHJpbmcoKSlcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHNhdmUgZGVib3VuY2UgZGVsYXkgdG8gc3RvcmFnZTonLCBlcnJvcilcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtdKVxuXG4gIC8vIEdldCBjdXJyZW50IGRlYm91bmNlIGRlbGF5XG4gIGNvbnN0IGdldERlYm91bmNlRGVsYXkgPSB1c2VDYWxsYmFjaygoKSA9PiBkZWJvdW5jZURlbGF5LCBbZGVib3VuY2VEZWxheV0pXG5cbiAgLy8gR2V0IGNhY2hlIHN0YXRpc3RpY3NcbiAgY29uc3QgZ2V0Q2FjaGVTdGF0cyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCByYXRpbmdzID0gQXJyYXkuZnJvbShwZW5kaW5nUmF0aW5ncy52YWx1ZXMoKSlcbiAgICBjb25zdCBvbGRlc3RUaW1lc3RhbXAgPSByYXRpbmdzLmxlbmd0aCA+IDAgXG4gICAgICA/IE1hdGgubWluKC4uLnJhdGluZ3MubWFwKHIgPT4gci50aW1lc3RhbXApKVxuICAgICAgOiBudWxsXG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHBlbmRpbmdDb3VudDogcGVuZGluZ1JhdGluZ3Muc2l6ZSxcbiAgICAgIG9sZGVzdFRpbWVzdGFtcFxuICAgIH1cbiAgfSwgW3BlbmRpbmdSYXRpbmdzXSlcblxuICAvLyBMb2FkIGRlYm91bmNlIGRlbGF5IGZyb20gc3RvcmFnZSBvbiBpbml0aWFsaXphdGlvblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3RvcmVkRGVsYXkgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShERUJPVU5DRV9ERUxBWV9LRVkpXG4gICAgICAgIGlmIChzdG9yZWREZWxheSkge1xuICAgICAgICAgIGNvbnN0IGRlbGF5ID0gcGFyc2VJbnQoc3RvcmVkRGVsYXksIDEwKVxuICAgICAgICAgIGlmICghaXNOYU4oZGVsYXkpICYmIGRlbGF5ID49IDEwMDAgJiYgZGVsYXkgPD0gMzAwMDApIHtcbiAgICAgICAgICAgIHNldERlYm91bmNlRGVsYXlTdGF0ZShkZWxheSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGxvYWQgZGVib3VuY2UgZGVsYXkgZnJvbSBzdG9yYWdlOicsIGVycm9yKVxuICAgICAgfVxuICAgIH1cbiAgfSwgW10pXG5cbiAgY29uc3QgdmFsdWU6IFJhdGluZ0NhY2hlQ29udGV4dFR5cGUgPSB7XG4gICAgcGVuZGluZ1JhdGluZ3MsXG4gICAgc2V0Q2FjaGVkUmF0aW5nLFxuICAgIGdldENhY2hlZFJhdGluZyxcbiAgICBoYXNQZW5kaW5nUmF0aW5nLFxuICAgIGZsdXNoUGVuZGluZ1JhdGluZ3MsXG4gICAgc2V0RGVib3VuY2VEZWxheSxcbiAgICBnZXREZWJvdW5jZURlbGF5LFxuICAgIGdldENhY2hlU3RhdHNcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPFJhdGluZ0NhY2hlQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17dmFsdWV9PlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvUmF0aW5nQ2FjaGVDb250ZXh0LlByb3ZpZGVyPlxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VSYXRpbmdDYWNoZSgpIHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoUmF0aW5nQ2FjaGVDb250ZXh0KVxuICBpZiAoY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1c2VSYXRpbmdDYWNoZSBtdXN0IGJlIHVzZWQgd2l0aGluIGEgUmF0aW5nQ2FjaGVQcm92aWRlcicpXG4gIH1cbiAgcmV0dXJuIGNvbnRleHRcbn0iXSwibmFtZXMiOlsiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlQ2FsbGJhY2siLCJ1c2VSZWYiLCJ1c2VTZXNzaW9uIiwidG9hc3QiLCJSYXRpbmdDYWNoZUNvbnRleHQiLCJ1bmRlZmluZWQiLCJERUZBVUxUX0RFQk9VTkNFX0RFTEFZIiwiTUFYX0NBQ0hFX0FHRSIsIlNUT1JBR0VfS0VZIiwiREVCT1VOQ0VfREVMQVlfS0VZIiwiUmF0aW5nQ2FjaGVQcm92aWRlciIsImNoaWxkcmVuIiwiZGF0YSIsInNlc3Npb24iLCJwZW5kaW5nUmF0aW5ncyIsInNldFBlbmRpbmdSYXRpbmdzIiwiTWFwIiwiZGVib3VuY2VUaW1lciIsInNldERlYm91bmNlVGltZXIiLCJkZWJvdW5jZURlbGF5Iiwic2V0RGVib3VuY2VEZWxheVN0YXRlIiwiaXNJbml0aWFsaXplZCIsInNldElzSW5pdGlhbGl6ZWQiLCJmbHVzaFBlbmRpbmdSYXRpbmdzUmVmIiwiZ2V0Q2FjaGVLZXkiLCJ2aWRlb0lkIiwidGFnSWQiLCJsb2FkRnJvbVN0b3JhZ2UiLCJzdG9yZWQiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwicGFyc2VkIiwiSlNPTiIsInBhcnNlIiwicmF0aW5nc01hcCIsIm5vdyIsIkRhdGUiLCJmaWx0ZXJlZE1hcCIsImZvckVhY2giLCJyYXRpbmciLCJrZXkiLCJ0aW1lc3RhbXAiLCJzZXQiLCJlcnJvciIsImNvbnNvbGUiLCJ3YXJuIiwic2F2ZVRvU3RvcmFnZSIsInJhdGluZ3MiLCJyYXRpbmdzQXJyYXkiLCJBcnJheSIsImZyb20iLCJlbnRyaWVzIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsImNsZWFyU3RvcmFnZSIsInJlbW92ZUl0ZW0iLCJzZXRDYWNoZWRSYXRpbmciLCJ0b0lTT1N0cmluZyIsInNwbGl0IiwibG9nIiwicGVuZGluZ1JhdGluZyIsInByZXYiLCJuZXdNYXAiLCJjbGVhclRpbWVvdXQiLCJuZXdUaW1lciIsInNldFRpbWVvdXQiLCJjdXJyZW50IiwiZ2V0Q2FjaGVkUmF0aW5nIiwicGVuZGluZyIsImdldCIsImNvcnJ1cHRlZEtleSIsImNsZWFuZWQiLCJkZWxldGUiLCJoYXNQZW5kaW5nUmF0aW5nIiwiZmx1c2hQZW5kaW5nUmF0aW5ncyIsInNpemUiLCJhY3R1YWxQZW5kaW5nUmF0aW5ncyIsInZhbHVlcyIsImZpbHRlciIsImxlbmd0aCIsInJhdGluZ3NUb1NhdmUiLCJyZXN1bHQiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImNyZWRlbnRpYWxzIiwiYm9keSIsIm1hcCIsIm9rIiwiZXJyb3JEYXRhIiwianNvbiIsImNhdGNoIiwiRXJyb3IiLCJtZXNzYWdlIiwic3RhdHVzIiwic3VjY2VzcyIsInByb2Nlc3NlZCIsInN1Y2Nlc3NmdWwiLCJmYWlsZWQiLCJoYXNFcnJvcnMiLCJlcnJvcnMiLCJlcnJvckNvdW50IiwicmVzdWx0cyIsInN1Y2Nlc3NmdWxLZXlzIiwiU2V0IiwiZmFpbGVkS2V5cyIsImlzQXJyYXkiLCJhZGQiLCJuZXdQZW5kaW5nUmF0aW5ncyIsImV4cGVjdGVkS2V5Iiwid2FzSW5GbHVzaEJhdGNoIiwic29tZSIsImZsdXNoZWRSYXRpbmciLCJoYXMiLCJzdG9yZWRSYXRpbmdzIiwiY2xlYW51cEludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJoYXNFeHBpcmVkUmF0aW5ncyIsImN1cnJlbnRUaW1lIiwiY2xlYXJJbnRlcnZhbCIsImhhbmRsZUJlZm9yZVVubG9hZCIsInJhdGluZ3NEYXRhIiwibmF2aWdhdG9yIiwic2VuZEJlYWNvbiIsImhhbmRsZVZpc2liaWxpdHlDaGFuZ2UiLCJkb2N1bWVudCIsInZpc2liaWxpdHlTdGF0ZSIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwic2V0RGVib3VuY2VEZWxheSIsImRlbGF5IiwidmFsaWRhdGVkRGVsYXkiLCJNYXRoIiwibWF4IiwibWluIiwidG9TdHJpbmciLCJnZXREZWJvdW5jZURlbGF5IiwiZ2V0Q2FjaGVTdGF0cyIsIm9sZGVzdFRpbWVzdGFtcCIsInIiLCJwZW5kaW5nQ291bnQiLCJzdG9yZWREZWxheSIsInBhcnNlSW50IiwiaXNOYU4iLCJ2YWx1ZSIsIlByb3ZpZGVyIiwidXNlUmF0aW5nQ2FjaGUiLCJjb250ZXh0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./contexts/RatingCacheContext.tsx\n"));

/***/ })

});